# 十二、应用

1. 尽管深度学习的一个目标是：设计能够处理各种任务的算法。但是截至目前，深度学习的应用仍然需要一定程度的特化
   - 计算机视觉中的任务对每一个样本都需要处理大量的输入特征（像素）
   - 自然语言处理的每一个输入特征都需要对大量可能值（词汇表中的词）建模

## 1. 大规模深度学习

1. 深度学习的基本思想基于联结主义：尽管机器学习模型中，单个生物性的神经元不是智能的，但是大量的神经元作用在一起可以表现出智能

   - 必须重点强调神经元数量必须很大这个事实
   - 由于规模的大小对于神经网络来说至关重要，因此深度学习需要高性能的硬件和软件实现

2. 传统的神经网络时单台机器的 CPU 来训练。如今这种做法被认为是不可取的

3. 许多现代神经网络的实现基于 GPU 来训练

   - 由于实现高效 GPU 代码的困难性，人们通常会选择一个软件库而不是编写新的 GPU 代码来实现算法

4. 许多情况下，单台机器的计算资源是有限的，因此我们希望把训练或者推断的任务分摊到多个机器上进行

   - 数据并行：进行分布式的推断。因为每个输入的样本都可以在单独的机器上运行，所以数据并行很容易实现
   - 模型并行：多个机器共同运行一个数据点，每个机器负责模型的一部分。对于训练和推断，这也是可行的

5. 在训练过程中的数据并行有一定的困难

   - 我们可以增加单个 `SGD`步中的 `minibatch`的大小，但是我们获取的性能优化低于线性的

   - 我们也可以考虑并行的求解多个梯度，但是很不幸的是： 第 $t $ 步梯度依赖于 第 $t-1$ 步的迭代梯度，这是一个完全串行的过程

     - 这个问题可以使用异步随机梯度下降来解决。几个处理器的核公用存有参数的内存；每个核在无锁的情况下读取这些参数并计算对应的梯度，然后在无锁的状态下更新这些参数

       > 之所以用无锁，是因为加锁和等待锁的时间成本太高。这里虽然无锁会导致数据冲突，但是并不会影响算法的正确性（因为每个迭代步的结果都是沿着目标函数值下降的方向）

     - 由于一些核把其他的核所更新的参数覆盖了，因此这种方法减少了每一步梯度下降所获得的平均提升

     - 但是因为更新步数的速度（单位时间内，更新步的数量）增加，总体上还是加快了学习过程

     - 也可以将参数放到参数服务器上管理，而不是放到公用的内存中

### 1.1 模型压缩

1. 许多商业应用的机器学习模型中，一个时间和内存开销比较小的推断算法比一个时间和内存开销较小的训练算法更重要
   - 对于那些不需要特殊设计的应用来说，我们只需要一次性的训练模型，就可以被重复使用
   - 相比较开发过程，应用过程可能拥有的资源非常有限。比如可以在超大计算机集群上训练一个语音识别网络，然后将其部署在手机上
2. 降低推断开销的一个关键策略是：模型压缩
   - 基本思想是：用一个更小的模型来代替原始的、耗时的模型，从而使得用来存储于评估所需的内存和运行时间更少
   - 当原始模型的规模很大，且我们需要防止过拟合时，模型压缩就可以起到作用
3. 我们的大模型能够学习到某个函数 $f(x)$，但是由于训练样本数量有限，因此模型的参数数量往往会超过任务所需的参数数量（过拟合）
   - 我们将 $f$ 作用于无穷多的随机采样点 $x $，从而生成无穷多的训练样本组成训练集
   - 然后我们用这个新的训练集来训练一个更小的模型，使得它能够在这些点上拟合 $f(x)$
   - 为了充分利用这个新的小模型的容量，最好从类似于真实测试数据的分布中采样 $x$ 。这个过程可以通过损坏训练样本，或者从原始训练数据的生成模型中采样完成

### 1.2 动态结构

1. 加速数据处理系统的一种策略是：构造一个动态结构的系统来处理输入
   - 动态系统：系统可以动态的决定使用哪一部分来处理输入（类似多路开关）
   - 对于神经网络，网络可以动态决定运行网络中的哪一部分
   - 单个神经元内部也可以存在动态结构：给定输入信息，隐单元决定哪些特征参与计算。只计算这些必要的特征会起到加速的目的
2. 在分类任务中，加速推断这一过程的一种策略是：使用级联分类器。当目标是检测某个对象是否存在时：
   - 我们训练一系列的分类器。第一个分类器被训练为具有很高的召回率，最后一个分类器被训练为具有很高的精度
   - 在推断时，我们按照顺序运行这些分类器。一旦级联中的任何一个发现不包含该对象，则抛弃
   - 由于前面的分类器通常都是低容量，因此如果一旦发现不包含该对象，则立即返回；没必要每次都运行最后一个高精度的分类器（容量较大，计算量也较大）
3. 级联分类器的另一个版本是：级联分类器前面的成员负责定位对象；后续成员在给定对象位置的情况下执行进一步处理
4. 决策树是动态结构的一个例子
   - 树中的每个中间节点决定：应该使用哪个子树来评估输入
   - 一个结合深度学习和动态结构的简单方法是：训练一个决策树，其中每个中间节点使用神经网络做出决策（这个策略不会加速推断计算）
5. 我们可以使用一种称作选通器 `gater`的神经网络来选择：在给定当前输入的情况下，将使用多个专家网络中的哪个来计算输出。这也是动态结构的一个例子
   - 第一个版本被称作专家混合体：其中选通器为每个专家输出一个概率或者权重。最终的输出由各个专家输出的加权组合获得。此时并不会降低计算成本
   - 如果每个样本的选通器选择的是单个专家，则我们获得一个特殊的硬专家混合体，这可以加速训练和推断
6. 另一个动态结构的例子是开关：其中隐单元可以根据具体情况从不同单元接受输入
   - 这种动态路由的方法可以理解为注意力机制
   - 目前为止，其使用在大规模应用中还没有被证明是有效的
   - 一个改进的做法是：采用对许多可能的输入使用加权平均，因此不能完全得到动态结构所带来的计算效益
7. 动态结构系统的主要缺陷是：由于系统针对不同输入的不同处理方式，导致并行度降低
   - 我们可以将样本分组，使得每一组的样本都采用相同的处理方式来缓解该问题。但是在实时系统中，这会导致负载均衡问题（因为不同组的样本数量千差万别）

## 2. 计算机视觉

1. 视觉对于人类以及许多动物毫不费力，但是对于计算机却充满挑战
   - 深度学习中许多流行的标准基准任务包括：对象识别，以及光学字符识别

### 2.1 预处理

1. 图像应该被标准化，从而使得它们的像素都在相同并且合理的范围内。如 [0,1] 或者 [-1,1] 或者 [0,255]

   - 不同范围的像素不能混合在一起

   - 将图像格式化为具有相同的比例是唯一一个必要的预处理。许多计算机视觉框架需要标准尺寸的图像，因此必须裁剪或者缩放图像以适应该尺寸

     > 实际上，缩放图像的操作并不总是必要的。有些卷积模型接受可变大小的输入并动态调整它们的池化区域大小从而保持输出大小恒定；有些卷积模型具有可变大小的输出，其尺寸随输入自动缩放

2. 数据集增强可以看做是一种只对训练集做预处理的方式

   - 在计算机视觉中，数据集增强是减少泛化误差的一种极好的方法
   - 在测试时，可以考虑将同一个输入的不同版本传给模型来预测（如稍微不同的位置处裁剪相同图像）

3. 其他一些预处理方式同时应用于训练集和测试集，如每个像素减去训练样本的平均值。这些目的是将每个样本置于更规范的形式

#### 2.1.1 对比度归一化

1. 对比度：指的是图像中亮像素和暗像素之间差异的大小。度量图像对比度有多种方式

   - 深度学习中，对比度通常指的是图像整体或者图像区域中像素的标准差
   - 假设图像为 张量 $\mathbf X \in \mathbb R^{r\times c\times 3}$， 其中 $X_{i,j,1},X_{i,j,2},X_{i,j,3}$ 分别表示第 $i$ 行 第 $j$  列红色、绿色、蓝色的强度。则整个图像的对比度为:

   $$
   \sqrt{\frac {1}{3rc}\sum_{i=1}^r\sum_{j=1}^c\sum_{k=1}^3(X_{i,j,k}-\bar{\mathbf X})^2}
   $$

   ​	其中 $\bar{\mathbf X}$ 为整个图片的平均强度：
   $$
   \bar{\mathbf X}=\frac {1}{3rc}\sum_{i=1}^r\sum_{j=1}^c\sum_{k=1}^3 X_{i,j,k}
   $$

2. 全局对比度归一化`global contrast normalization:GCN`：每个图像中减去其平均值，然后重新缩放使其每个像素上的标准差等于某个常数 $s$ 防止图像具有变化的对比度

   - 没有缩放因子来改变 0 对比度的图像的对比度
   - 具有非常低但是非零对比度的图像通常几乎没有信息内容。此时如果执行全局对比度归一化，则仅能放大传感器噪声或者压缩一些虚假的图像

3. 带正则化的全局对比度归一化：引入小的正则化参数 $\lambda $  来平衡估计的标准差。输出图像为：
   $$
   X^\prime_{i,j,k}=s\frac{X_{i,j,k}-\bar{\mathbf X}}{\max \{\epsilon,\sqrt{\lambda+\frac {1}{3rc}\sum_{i=1}^r\sum_{j=1}^c\sum_{k=1}^3(X_{i,j,k}-\bar{\mathbf X})^2}\}}
   $$
   ​

   其中 $\epsilon$ 用于约束分母，使其非零。

   - 从大图像中裁剪的、由所感兴趣对象组成的数据集不可能包含任何强度几乎恒定的图像。此时可以设置 $\lambda=0$ 。同时为了避免在非常罕见的情况下分母为 0，设置 $\epsilon$ 为一个非常小的数，如 $\epsilon=10^{-8}$ 
   - 随机裁剪的小图像更可能具有几乎恒定的强度（标准差为 0），此时需要设置 $\lambda $  为一个激进的值，如 $\lambda=10$
   - $s$ 通常设置为1

4. 我们可以把全局对比度归一化理解为到球壳的一种映射

   - 因为神经网络往往更好的响应空间方向，而不是精确的位置

     ![GCN](../imgs/12/GCN.png) 

5. 另一种 `sphering`的预处理操作：它并不会使得数据位于球壳上，而是将主成分重新压缩从而具有相等方差，使得 PCA 使用的多变量正态分布具有球形等高线

   - `sphering` 通常被称作白化

6. 全局对比度归一化通常并不能突出我们想要突出的图像特征，如边缘和角。这催生出了局部对比度归一化`local contrast normalization:LCN`

   -  局部对比度归一化确保对比度在每个小窗口上被归一化

   - 局部对比度归一化的各种定义都是可行的。

     - 我们可以减去临近像素的均值，并处以临近像素的标准出来修改每个像素
     - 也可以使用被处理像素为中心的矩形窗口中所有像素的均值和标准差
     - 也可以使用加权均值和加权标准差

     ![LCN](../imgs/12/LCN.png) 

7. 全局对比度归一化使得所有图片的尺度都差不多，这减轻了学习算法处理多个尺度的负担。局部对比度归一化更多的改变了图像，丢弃了所有相同强度的区域，使得模型能够只关注于边缘

8. 我们通常需要正则化局部对比度归一化来避免出现处理 0 的情况

   - 因为局部对比度归一化通常作用于较小的窗口，所以正则化更加重要

### 2.2 数据集增强

1. 我们可以通过对原始图像进行一些变化、但是不改变其类别来增加训练集的额外样本
   - 对象识别任务特别适合这种形式的数据集增强。因为类别信息对于许多变换是不变的

## 3. 语音识别

1. 语音识别任务：将一段包含了自然语言发音的声学信号映射到词序列上。 令 $\mathbf {\vec X}=(x^{(1)},x^{(2)},\cdots,x^{(T)})$ 表示语音的输入向量
   - 传统的方法需要特殊的手工设计方法预处理输入信号，从中提取特征
   - 深度学习系统从原始输入中提取特征
2. 传统的语音识别系统是：隐马尔科夫模型与高斯混合模型的结合
   - 高斯混合模型对声学特征和音素之间的关系进行建模
   - 隐马尔科夫模型对音素序列建模
   - 建模过程如下：
     - 首先，一个 HMM 生成了一个音素的序列以及离散的子音素状态（如：每个音素的开始、中间、结尾）
     - 然后 GMM 把每一个离散的状态转化为一个简短的声音信号

## 4. 自然语言处理

1. 我们将自然语言视作一系列词，而不是单个字符或者字节序列

2.  `n-gram`模型：包含 `n` 个标记的序列

   - 基于`n-gram`的模型：定义了一个条件概率：给定前 `n-1`个标记后的第 `n` 个标记的条件概率：
     $$
     P(x_1,x_2,\cdots,x_\tau)=P(x_1,\cdots,x_{n-1})\prod_{t=n}^{\tau}P(x_t\mid x_{t-n+1},\cdots,x_{t-1})
     $$

     > 当 $n=2$ 时，  $P(x_1,x_2,x_3)=P(x_1)P(x_2\mid x_1)P(x_3\mid x_2)$ ，即以 $n$ 个单词为一组，不同组之间的在概率图上不相连

   - 训练 `n-gram` 模型是简单的，简单统计每个可能的 `n-gram`即可

   - 几十年依赖，基于`n-gram`的模型都是统计语言的核心模块

   - 对于小的 `n` 值：`n=1`称作一元语言模型`unigram`；`n=2`时称作二元语言模型`bigram`；`n=3`时称作三元语言模型`trigram`

   - 大多数 `n-gram` 模型都采用了某种形式的平滑

     - 一种方法是：基于向所有可能的下一个符号值添加非零概率质量
     - 另一种方法是：包含了高阶和低阶的 `n-gram`模型的混合模型。其中高阶模型提供更大的容量，而低阶模型尽可能避免零计数

3.  经典的 `n-gram` 模型特别容易引起维数灾难

   - 因为字典大小 $|\mathbb V|$  通常很大，导致 $|\mathbb V|^n$  非常大
   - 即使有大量的训练数据和适当的 $n$ ，大多数 `n-gram` 也不会出现在训练集中
   - 任何不同的两个词在`one-hot`向量空间中的距离彼此相同，因此难以利用来自任意“邻居”的信息
     - 只有重复上下文的训练样本对于局部泛化才起作用

### 4.1 神经语言模型

1. 神经语言模型`Neural language Model:NLM` 使用词的分布式表达来对自然语言序列建模
   - 它克服了维数灾难
   - NLM 能够识别两个相似的词，并且将不同的词给予不同的编码
2. 词的分布式表达也称作词嵌入 `word embedding`
   - 原始空间中，每个词由一个 one-hot 向量表示，每对词之间的欧氏距离都是 $\sqrt 2$ 
   - 在嵌入空间中，它的维数较低。经常出现类似上下文的词汇彼此接近，这通常导致相似含义的词变得临近
3. 使用分布式表达来改进自然语言处理模型的思想不必局限于神经网络。还可以应用于图模型，其中分布式表达是多个隐变量的形式。

#### 4.1.1 高维输出

1. 通常我们希望模型产生词而不是字符作为基本的输出单位。对于大的词汇表，由于词汇量很大，则表示输出分布的计算成本可能非常高

   - 假设 $\mathbb V$ 包含数十万单词。假设隐层到输出空间为一个仿射变换加一个 `softmax` 函数。

   - 假设输出维数为 $|\mathbb V|$ ，则描述仿射变换的权重矩阵非常庞大，这造成了该矩阵的存储成本太高

   - 因为`softmax`需要在所有 $|\mathbb V|$ 输出之间归一化，导致在训练和推断时，计算成本太高

   - 如果使用输出层的交叉熵作为损失函数，则计算损失函数的梯度时，计算量也非常庞大

   - 令  $\mathbf{\vec h}$ 为输出的顶部隐层；  $\mathbf W,\mathbf{\vec b}$ 为仿射变换的参数； $\hat{\mathbf{\vec y}}$ 为 `softmax` 的输出
     $$
     a_i=b_i+\sum_j W_{ij}h_j \quad \forall i \in \{1,2,...,|\mathbb V|\}
     $$

     $$
     \hat y_i=\frac{e^{a_i}}{\sum_{k=1}^{|\mathbb V|}e^{a_k}}
     $$

     > 假设  $\mathbf{\vec h}$  包含 $n_h$ 个元素，则上述操作复杂度为 $O(|\mathbb V|n_h)$ 。当 $n_h$ 为数千， $|\mathbb V|$ 为数十万时，该操作在所有计算量中占主导

2. 可以将词汇表 $\mathbb V$ 划分为两个部分：最常见词汇的短列表 $\mathbb L$ （由神经网络处理），以及由稀有词汇的尾列表 $\mathbb T=\mathbb V-\mathbb L$ （由 `n-gram`模型处理）

   - 为了组合这两个预测，神经网络必须预测在上下文 $C$  之后，出现的词位于尾列表的概率

   - 我们可以添加额外的 `sigmoid`输出单元来估计 $P(i\in \mathbb T\mid C)$  来实现这个预测；
     $$
     P(y=i\mid C)=1_{i \in \mathbb L}P(y=i\mid C,i\in \mathbb L)(1-P(i\in \mathbb T\mid C))\\
     +1_{i\in \mathbb T} P(y=i\mid C,i\in \mathbb T)P(i\in \mathbb T\mid C)
     $$
     这里：

     - $1_{i\in \mathbf L}$ 表示 $i\in \mathbb L $ 时，取值为 1；否则取值为 0
     - $P(y=i\mid C,i\in \mathbb L)$ 由神经语言模型提供
     - $ P(y=i\mid C,i\in \mathbb T)$  由 `n-gram` 模型提供

   - 短列表方法的一个明显缺点是：神经语言模型的潜在泛化优势仅限于最常用的词，但是这没有什么用处

3. 减少大词汇表 $\mathbb V$ 上高维输出层计算负担的经典方法是：分层分解概率，使得 $|\mathbb V|$ 可以降低到 $\log |\mathbb V|$ 

   - 我们可以认为这种层次结构是：先建立词的类别，然后是词类别的类别，然后是词类别的类别的类别....
   - 这些层次结构组成了一颗树，其叶子为词。选择一个词的概率是由路径上每个节点通向该词分支概率的乘积给出
   - 如果是平衡树，则树的深度为 $\log|\mathbb V|$
   - 我们为这些模型提供与输入相同的上下文 $C$ ，我们需要给出树的每个节点的条件概率
     - 因为正确的输出编码在训练集中，我们可以使用监督学习训练 LR 模型
     - 我们通常使用交叉熵作为损失函数，这对应于最大化正确序列的对数似然
   - 优化树结构的最小期望是可能的，但是通常是不切实际的。给定词的相对频率，信息论工具可以指定如何选择最佳的二进制编码，因此我们可以这样构造树：使得词相关联的比特位的数量近似等于该词频率的对数。
   - 但是实践中，节省计算通常得不偿失，因为输出概率的计算仅仅是神经语言模型总计算的一部分
     - 假设有 $l$  个全连接的宽度为 $n_h$ 的隐层。令 $n_b$ 为识别一个词所需比特位的加权平均值，其加权由这些词的频率给出
     - 此时，隐层激活所需的操作数为 $O(n_h^2l)$ ；输出所需的操作数为 $O(n_hn_b)$ 。事实上词汇表大小很少超过一百万，我们可以将 $n_b$ 设置为大约20；但是 $n_h$  通常要大得多，约为 1000 或者更大  
   - 如何定义词的层次结构是个未决的问题。一个方法是学习层次结构，但是由于它是离散的，不适用于梯度优化
   - 即使采用分层`softmax`，计算所有 $|\mathbb V|$ 个词的概率的计算成本仍然很高。另外分层`softmax`效果比基于采样的方法要差

4. 分层的示例如下：

   - 叶子节点表示实际上特定的词，内部节点表示词的组别

   - 任何节点都可以通过二值决策序列 （0=左，1=右） 来索引，从根到达节点

   - $w_4$ 的概率可以如下分解：
     $$
     P(y=w_4)=P(b_0=1,b_1=0,b_2=0)\\
     =P(b_0=1)P(b_1=0\mid b_0=1)P(b_2=0\mid b_0=1,b_1=0)
     $$
     ​

   ![nlp_tree](../imgs/12/nlp_tree.png)

5. 加速神经语言模型训练的一种方式是：避免计算所有未出现在下一个位置的词对于梯度的贡献

   - 每个不正确的词在此模型下具有较低的概率。枚举所有这些词的计算成本可能会非常高

   - 相反，我们可以仅采样词的子集

   - 根据：
     $$
     a_i=b_i+\sum_j W_{ij}h_j \quad \forall i \in \{1,2,...,|\mathbb V|\}
     $$

     $$
     \hat y_i=\frac{e^{a_i}}{\sum_{k=1}^{|\mathbb V|}e^{a_k}}
     $$

     梯度写作：
     $$
     \frac{\log P(y\mid C)}{\partial \theta}=\frac{\partial \log \text{softmax}_y(\mathbf{\vec a})}{\partial \theta}\\
     =\frac{\partial}{\partial \theta}\log \frac{e^{a_y}}{\sum_i e^{a_i}}\\
     =\frac {\partial}{\partial\theta}(a_y-\log\sum_i e^{a_i})\\
     =\frac{\partial a_y}{\partial \theta}-\sum_i P(y=i\mid C)\frac{\partial a_i}{\partial \theta}
     $$

     - 其中 $\mathbf{\vec a}$ 是激活向量（或者称作得分向量），每个词对应一个元素。
     - 梯度的第一项是正相`positive phase`项，推动 $a_y$  向上；第二项是负相`negative phase`，对于所有$i$ 以权重 $P(i\mid C)$  推动 $a_i$  向下
     - 第二项是期望值，因此我们可以通过蒙特卡洛采样估计。但是它需要从模型本身采样：对词汇表中所有的 $i$ ，计算 $P(i\mid C)$ ，而这正是我们待求的。

   - 我们可以从另一个分布中采样，而不是从模型中采样，这称作建议分布`proposal distribution`（记做 $q$ ) ，然后通过适当的权重校正从错误分布采样引入的偏差。这种方式称作：重要采样`Importance Sampling`

   - 即使是精确重要采样也不一定有效，因为我们需要计算权重 $\frac {p_i}{q_i}$ ，其中的 $p_i=P(i\mid C)$  只能在计算所有得分 $a_i $ 后才能计算

### 4.2 结合 n-gram 和神经语言模型

1. `n-gram ` 模型的主要优点是：具有更高的模型容量，并且处理样本只需要非常少的计算量。
2. 增加模型容量的一种简单方法是：通过集成方法，将两者结合起来

### 4.3 神经机器翻译

1. 一个简单的方式是：给定源语言中的短语 $s_1,s_2,\cdots,s_k$ ，使用 MLP 对目标语言的短语 $t_1,t_2,\cdots t_k$  进行评分

   - MLP 估计 $P(t_1,t_2,\cdots,t_k\mid s_1,s_2,\cdots,s_k)$
   - 这种方式的缺点是：需要将序列预处理为固定长度

2. 另一种方式是：采用 RNN 循环神经网络：

   - 一个模型（可以是 RNN 或者 CNN）首先读取输入序列，并产生概括了输入的数据结构（称作上下文 $C$ ）

   - 另一个模型（通常是 RNN）读取上下文 $C$  并生成目标语言的句子

     ![translate](../imgs/12/translate.png)

3.  使用固定大小的表达来概括非常长的句子的所有语义细节是非常困难的，这需要足够大的 RNN，以及足够长的时间训练

     - 更高效的方式是：先读取整个句子或者段落（以获得正在表达的上下文和焦点），然后一次翻译一个词。每次聚焦于输入句子的不同部分来收集产生下一个输出词所需的语义细节。这称作注意力机制

     - 注意力机制的系统有三个组件：

       - 读取器读取原始数据（如源语句中的源词），并将其转换为分布式表达，其中一个特征向量与每个词的位置相关联
       - 存储器存储读取器输出的特征向量列表
       - 最后一个程序利用存储器的内容顺序执行任务（如生成翻译语句），每个时间步聚焦于某个存储器元素的内容（或者几个，具有不同权重）

     - 下图为示意图。注意力机制本质是加权平均。注意力机制对具有权重 $\alpha ^{(t)}$  的特征向量 $\mathbf{\vec h}^{(t)}$  进行加权平均形成上下文向量 $\mathbf{\vec c }$ 

       - 权重 $\alpha ^{(t)}$  是由模型本身产生的，它们通常是区间 [0,1] 之间的值

       ![attention](../imgs/12/attention.png)

##5. 其他应用 

### 5.1 推荐系统

1. 早期的推荐系统依赖于最少数量的信息：用户 ID 和商品 ID，通常基于协同过滤算法。

2. 我们也可以基于参数方法：为每个用户和每个商品学习其嵌入表达（类似于 word2vec）

   - 令 $\hat {\mathbf R}$  是包含我们预测的矩阵， $\mathbf A$  矩阵行中是用户嵌入； $\mathbf B$  矩阵列中是项目嵌入。令 $\mathbf {\vec b}$  和 $\mathbf{\vec c}$  分别包含针对每个用户（表示用户的喜好偏好）以及每个商品（表示商品的受欢迎程度）的偏置向量，则有：
     $$
     \hat R_{u,i}=b_u+c_i+\sum_j A_{u,j}B_{j,i}
     $$

   - 通常我们希望最小化预测评级 $\hat R_{u,i}$  和实际评级 $R_{u,i}$  之间的平方误差

   - 获得这些嵌入表达的一种方式是：对实际的评价矩阵 $\mathbf R$ 进行奇异值分解： $\mathbf R=\mathbf U\mathbf D\mathbf V$ 

     - 其中 $\mathbf A=\mathbf U\mathbf D$，而 $\mathbf B=\mathbf V $ 
     - 其问题是：对于缺失项，其输出为 0.

   - 我们也可以基于评级的平方误差总和的梯度来进行优化

3. 协同过滤的一个基本限制是：冷启动问题。当引入新项目或者新用户时，缺乏评级历史。

   - 解决的一般方式是：引入用户或者商品的额外信息。这称作基于内容的推荐系统
   - 这些额外的信息可以采用专用的深度学习架构来提取

4. 当向用户推荐时，会产生超出了普通监督学习范围的问题，并进入强化学习的领域

   - 推荐系统的一个问题时：当我们使用推荐系统，并且收集推荐结果数据时，得到的是一个有偏的、不完整的用户偏好
     - 我们只能看到用户对推荐给他们相互的反应
     - 我们无法获得那些未向用户推荐的商品的反应。我们不知道推荐这些商品会有什么结果
   - 这种情况类似于强化学习：仅仅观察到所选动作的奖励

### 5.2 知识表达、推理、问答

1. 词嵌入表达给出了关于单个词或者概念的语义知识。 

2. 一个有趣的研究方向是：如何训练分布式表达才能捕获两个实体之间的关系

   - 数学上，二元关系是一组有序的二元对（如集合上定义的小于关系）
   - 在 AI 上，我们定义关系为：句法上简单、且高度结构化的语言。关系起到了动词的作用，关系的两个参数发挥着主体和客体的作用： `(subject,verb,object)`
   - 我们也可以定义属性，类似于关系的概念： $(\text{entity}_i,\text{attribute}_j)$ 

3. 许多应用需要关系和推理，而神经网络可以通过训练数据来发掘关系和完成推理

   - 实体和关系的表示可以将知识库中的每个三元组作为训练样本来学习，并最大化捕获它们的联合分布作为训练目标
   - 除了训练数据，还需要定义训练模型的模型族：
     - 一种常见方法是：将神经语言模型扩展到模型实体和关系。神经语言模型学习提供每个词分布式表达的向量，还通过学习这些向量的函数来学习词之间的相互作用（如哪些词可能出现在另一些词的后面）

4. 这种模型的实际短期应用是链接预测：预测知识图谱中缺失的弧。这是基于已有的知识推广新知识的一种形式

   - 我们很难评估其性能，因为我们的数据集只有正样本（已知是真实的事实）。如果模型挖掘了不在数据集中的事实，我们不确定模型是犯了错误还是发现了一个新的、以前未知的事实

5. 知识库和分布式表达的另一个应用是：词义消歧

6. 知识关系结合一个推理过程以及对自然语言的理解可以建立一个一般的问答系统

   - 目前这是一个困难的领域，只能在受限的“玩具”环境下解决

   ​