# 章八 深度模型中的优化
1. 深度学习中，优化问题很重要，代价也很高。因此开发了一组专门的优化技术

## 1. 深度模型优化算法的不同点
### 1.1 经验风险最小化

1. 机器学习通常是间接的：我们关注于测试集上的某个不可解的性能度量 \\(P\\) 。
	- 我们的做法是：希望通过降低代价函数 \\(J(\vec\theta)\\) 来提高 \\(P\\)。这不同于纯粹的最小化 \\(J\\) 本身

2. 通常情况下，代价函数可以采用训练集上的均值代替：
	$$J(\vec\theta)=\mathbb E\_{(\mathbf{\vec x},y)\sim \hat p\_{data}} L(f(\mathbf{\vec x};\vec\theta),y)$$
	- \\(L\\) 为每个样本的损失函数
	- \\(f(\mathbf{\vec x};\vec\theta)\\) 为对输入 \\(\mathbf{\vec x}\\) 的预测输出
	- \\(\hat p\_{data}\\) 是经验分布
	- 在监督学习中， \\(y\\) 为标记信息

	通常我们更迫切希望的是：最小化期望取自真实的数据生成分布 \\(p\_{data}\\) ，而不是有限个训练集上对应的经验分布 \\(\hat p\_{data}\\) 。即，我们希望最小化泛化误差的期望：
	$$J^{\*}(\vec\theta)=\mathbb E\_{(\mathbf{\vec x},y)\sim   p\_{data}} L(f(\mathbf{\vec x};\vec\theta),y) $$

3. 问题是：对于绝大多数问题，我们不知道样本的真实分布 \\(p\_{data}\\)；我们仅仅知道训练集中的样本的分布。

	一个简单方案是：使用经验分布  \\(\hat p\_{data}\\)  来代替真实分布  \\(p\_{data}\\)。此时将机器学习问题转化为最小化训练集上的期望损失，即最小化经验风险`empirical risk`：
	$$\mathbb E\_{(\mathbf{\vec x},y)\sim  \hat p\_{data}}[ L(f(\mathbf{\vec x};\vec\theta),y)]=\frac 1N\sum\_{i=1}^{N}L(f(\mathbf{\vec x}\_i;\vec\theta),y_i) $$
	\\(N\\) 为训练样本的数量。

	- 这种方案被称作经验风险最小化 `empirical risk minimization`
	- 其缺点是：
		- 很容易过拟合 
		- 某些类型的损失函数（如 0-1 损失函数） 没有导数（导数要么为零，要么没有定义），无法使用梯度下降的优化算法来优化

4. 在深度学习中，我们很少使用经验风险最小化

### 1.2 替代损失函数 
1. 有时候我们关心的真正的损失函数无法有效优化：如精确地最小化 0-1 损失函数是不可解的。（复杂度几何级数增长于输入的维数）。
	- 此时我们考虑使用替代损失函数（如将正类的负对数似然函数作为 0-1 损失函数的替代）
	- 负对数似然函数作为替代损失函数可以从训练集中比 0-1 损失函数学得更多信息。

2. 一般的优化和机器学习优化的一个重要不同：机器学习算法通常并不收敛于局部极小值。
	- 机器学习算法通常优化替代损失函数
	- 机器学习算法可能会基于 7.8 节的收敛条件提前终止（即早停策略作为正则化）。
	- 通常提前终止采用的评判准则是：在验证集上，使用真实的损失函数来评估。
	>因此在提前终止发生时，替代损失函数仍然有较大的导数；而传统优化方法终止时，导数较小

### 1.3 minibatch 算法
1. 机器学习算法和一般优化算法不同的一点是：机器学习算法的目标函数通常可以分解为训练样本上的求和。


	因此：机器学习优化算法通常可以使用整个代价函数中的一部分项去更新其参数。

	如：最大似然估计：
	$$\vec\theta\_{ML}=\arg\max\_{\vec\theta}\sum\_{i=1}^{N}\log p\_{model}(\mathbf{\vec x}\_i,y_i;\vec\theta)$$

	最大化这个总和，等价于最大化训练集在经验分布上的期望：
	$$J(\vec\theta)=\mathbb E\_{(\mathbf{\vec x},y)\sim  \hat p\_{data}}\log p\_{model}(\mathbf{\vec x} ,y ;\vec\theta) $$

	当我们使用基于梯度的优化算法求解时，需要用到导数：
	$$\nabla\_\vec\theta J(\vec\theta)=\nabla\_\vec\theta [\mathbb E\_{(\mathbf{\vec x},y)\sim  \hat p\_{data}}\log p\_{model}(\mathbf{\vec x} ,y ;\vec\theta)]\\\
	= \mathbb E\_{(\mathbf{\vec x},y)\sim  \hat p\_{data}} \nabla\_\vec\theta\log p\_{model}(\mathbf{\vec x} ,y ;\vec\theta)$$
	- 这个导数本质上也是一个期望
	- 要准确的求解这个期望的计算量非常大，因为需要计算整个数据集上的每一个样本
	- 实践中，我们可以从数据集中随机采样少量的样本，然后计算这些样本上的梯度的导数的均值。然后将这个均值作为该期望的一个估计
	
	>独立同分布的 \\(n\\) 个样本的均值的标准误差为 \\(\frac{\sigma}{\sqrt{n}}\\) ，其中 \\(\sigma\\) 为样本值的真实标准差。
	>
	>- 该式表明：使用更多样本来估计梯度的方法的回报是低于线性的。当计算规模线性增加时，只降低了平方次的标准差。
	
2. 如果能够快速计算出梯度的估计值（而不是费时地计算准确值），则大多数优化算法会更快收敛
	> 因为每一步中计算梯度的时间大大缩短

3. 利用小数量样本来估计梯度的另一个原因是：训练集的冗余。
	- 最坏情况下， 训练集中的 \\(N\\) 个样本都是相同的拷贝。此时基于小数量样本估计梯度的策略能够计算正确的梯度，但是节省了大量时间
	- 实践中，我们可能发现：大量样本都对梯度做出了非常相似的贡献。

4. 使用整个训练集的优化算法被称作`batch`梯度算法（或者确定性`deterministic`梯度算法）；每次只使用单个样本的优化算法被称作随机`stochastic`算法（或者在线`online`算法）
	- 大多数深度学习的优化算法介于两者之间：使用一个以上、又不是采用全部的训练样本。称作`minibatch`或者`minibatch`随机算法。
	> 其典型示例：随机梯度下降法

5. `minibatch`的大小由下列因素决定：
	- 不能太大。更大的`batch`会得到更精确的梯度估计，但是回报是低于线性的
	- 不能太小。因为对于多核架构来讲，太小的`batch`并不会相应地减少计算时间（考虑到多核之间的同步开销）
	- 如果`batch`中所有样本可以并行地预处理，则内存消耗和`batch`大小成正比。对于许多硬件设备来说，这就是`batch`大小的限制因素
	- 在有些硬件上，特定大小的数列效果更好。
		- 在使用`GPU`时，通常使用 2 的幂作为`batch`大小
	- 可能是由于小`batch`处理在学习过程中加入了噪声扰动，它带来了一些正则化效果
		- 泛化误差通常在`batch`大小为 1 时最好
		- 但此时梯度估计值的方差非常大，因此需要非常小的学习速率以维持稳定性（如果学习速率过大，则导致步长的变化剧烈）
		- 由于需要降低学习速率，因此需要消耗更多的迭代次数来训练。虽然每一轮迭代中，计算梯度估计值的时间大幅度降低了（`batch`为 1），但是总的运行时间还是非常大。

6. 某些算法对采样误差非常敏感，此时`minibatch`效果较差。原因可能有两个：
	- 这些算法需要用到全部样本的一些精确信息，但是这些信息难以在少量样本上估计到
	- 这些算法会放大采样误差，导致误差积累越来越严重

	通常仅仅基于梯度 \\(\mathbf{\vec g}\\) 的更新方法相对更稳定，它能够处理更小的`batch`（如100）。

	如果使用了黑塞矩阵 \\(\mathbf H\\) （如需要计算 \\(\mathbf H^{-1}\mathbf{\vec g}\\) 的二阶方法） 通常需要更大的 `batch`（如 10000）
	- 如果 \\(\mathbf H\\) 被精确估计，但是它的条件数很差，那么乘以 \\(\mathbf H\\) 或者 \\(\mathbf H^{-1}\\) 会放大之前存在的误差。这就导致 \\(\mathbf{\vec g}\\) 的一个非常小的变化也会导致 \\(\mathbf H^{-1}\mathbf{\vec g}\\) 的一个非常大的变化
	> 因此 `batch`需要更大从而降低梯度的方差

	- 通常我们只是近似地估计  \\(\mathbf H\\)  ，因此只会引入更多的误差

7. `minibatch`是随机抽样的也非常重要
	- 从一组样本中计算出梯度期望的无偏估计要求这些样本是独立的

8. 我们也希望两个连续的梯度估计也是相互独立的，这要求：两个连续的`minibatch`样本也应该是彼此独立的

9. 实际应用中，采集的数据样本很可能出现这样的情况：连续的样本之间具有高度相关性。解决方法是：将样本随机混洗之后存储，以后训练时，按照混洗之后的顺序。
	- 这种打乱顺序不会对`minibatch`产生严重的影响。不打乱顺序的`minibatch`才会极大降低算法性能

	>比如统计人群的偏好，很可能连续的样本就是同一个家庭、同一个职业、同一个地域...

10. `minibatch`可以异步并行分布式更新：
	- 在计算`minibatch`的样本集合 \\(\mathbb X\\) 上的最小化 \\(J(\mathbb X)\\) 的更新时，也可以同时计算其他`minibatch`样本上的更新

11. 当 \\(\mathbf{\vec x},y\\) 都是离散时，泛化误差的期望：
	$$J^{\*}(\vec\theta)=\mathbb E\_{(\mathbf{\vec x},y)\sim   p\_{data}} L(f(\mathbf{\vec x};\vec\theta),y) \\\
	=\sum\_{(\mathbf{\vec x},y)} p\_{data}(\mathbf{\vec x},y) L(f(\mathbf{\vec x};\vec\theta),y)$$
	其梯度为：
	$$ \mathbf{\vec g}=\nabla\_{\vec\theta}J^{\*}(\vec\theta)=\sum\_{(\mathbf{\vec x},y)} p\_{data}(\mathbf{\vec x},y) \nabla\_{\vec\theta}L(f(\mathbf{\vec x};\vec\theta),y)$$

	泛化误差的梯度的无偏估计可以通过从数据生成分布 \\(p\_{data}\\) 抽取 `minibatch`样本 \\(\\{\mathbf{\vec x}\_1,\mathbf{\vec x}\_2,\cdots,\mathbf{\vec x}\_m\\}\\) 以及对应的标签 \\(\\{y_1,y_2,\cdots,y_m\\}\\)，然后计算`minibatch`上的损失函数对于\\(\vec\theta\\) 的梯度：
	$$\hat{\mathbf{\vec g}}= \frac 1m \nabla\_{\vec\theta}\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta),y\_i)  $$
	它就是 \\(\mathbf{\vec g}\\) 的无偏估计

	- 因此，`minibatch`随机梯度下降中，只要没有重复使用样本，它就是真实泛化误差梯度的无偏估计
	- 如果是在线学习，则每个样本或者`minibatch`都不会重复。每次更新都是独立地从真实分布 \\(p\_{data}\\) 中采样获得
	- 如果训练集不大，通常最好是多次遍历训练集。此时只有第一遍满足泛化误差的梯度的无偏估计。
		- 后续的遍历中，泛化误差的梯度估计不再是无偏的。
		- 但是后续的遍历会减小训练误差，从而抵消了训练误差和测试误差之间`gap`的增加，效果是减小了测试误差
	- 随着数据集规模的爆发增长，超过了计算能力的增长速度，现在普遍地对每个样本只使用一次，甚至不完整地使用训练集
		- 此时过拟合不再是问题，欠拟合以及计算效率成为主要问题

## 2. 神经网络优化中的挑战
1. 通常机器学习会仔细设计目标函数和约束，从而保证优化问题是凸的。但是神经网络中，通常遇到的都是非凸的

###2.1 病态
1.  黑塞矩阵 \\(\mathbf H\\) 是病态`ill-conditioning`这个情况，是凸优化或者其他形式优化中普遍存在的问题

2. 在神经网络训练过程中，如果  \\(\mathbf H\\) 是病态的，则随机梯度下降会“卡”在某些地方，此时即使很小的更新步长也会增加代价函数。

	我们将 \\(f(\mathbf{\vec x})\\) 在 \\(\mathbf{\vec x}\_0\\) 处泰勒展开：
	$$f(\mathbf{\vec x}) \approx f(\mathbf{\vec x}\_0)+(\mathbf{\vec x}-\mathbf{\vec x}\_0 )^{T}\mathbf{\vec g}+\frac 12(\mathbf{\vec x}-\mathbf{\vec x}\_0)^{T}\mathbf H (\mathbf{\vec x}-\mathbf{\vec x}\_0)$$
	其中 \\(\mathbf{\vec g}\\) 为 \\(\mathbf{\vec x}\_0\\) 处的梯度； \\(\mathbf H\\) 为 \\(\mathbf{\vec x}\_0\\) 处的海森矩阵。

	根据梯度下降法：
	$$\mathbf{\vec x}^{\prime}= \mathbf{\vec x}-\epsilon\nabla \_{\mathbf{\vec x}} f(\mathbf{\vec x})$$
	应用在点 \\(\mathbf{\vec x}\_0\\)，我们有：
	$$ f(\mathbf{\vec x}\_0-\epsilon\mathbf{\vec g})\approx f(\mathbf{\vec x}\_0)-\epsilon\mathbf{\vec g}^{T}\mathbf{\vec g}+\frac 12\epsilon^{2}\mathbf{\vec g}^{T}\mathbf H \mathbf{\vec g}$$
	
	因此沿着负梯度的方向，步长 \\(-\epsilon\mathbf{\vec g}\\) 将导致代价函数 \\(f\\) 增加
	$$-\epsilon\mathbf{\vec g}^{T}\mathbf{\vec g}+\frac 12\epsilon^{2}\mathbf{\vec g}^{T}\mathbf H \mathbf{\vec g}$$
	- 当 \\(\frac 12\epsilon^{2}\mathbf{\vec g}^{T}\mathbf H \mathbf{\vec g} \gt \epsilon\mathbf{\vec g}^{T}\mathbf{\vec g}\\) 时，梯度的病态会成为问题。
	- 在很多问题中，梯度的平方范数 \\(\mathbf{\vec g}^{T}\mathbf{\vec g}\\) 并不会在训练过程中显著缩小，而是随着时间增加，并不是随着训练过程收敛到临界点而减小。下面左图为梯度的范数随着时间的变化，右图为验证集上的分类误差随着时间的变化
	
		![ill_condition](../imgs/8/ill_condition.PNG)
	
	- 于此同时，\\(\mathbf{\vec g}^{T}\mathbf H\mathbf{\vec g}\\) 会更快速的增长（相对于 \\(\mathbf{\vec g}^{T}\mathbf{\vec g}\\)） 。其结果是：
		- 尽管梯度很强，但是学习会变得非常缓慢，因为学习率必须减小从而适应更强的曲率
		- 尽管梯度很强，但是训练却可以成功。因为它使得代价函数的增量不断逼近0（增量为0表示到达极值点）

3. 当黑塞矩阵是病态时，牛顿法是一个很好的解决方案。
	- 但是牛顿法并不适用于神经网络。需要对它进行较大改动才能用于神经网络

### 2.2 局部极小值
1. 对于非凸函数，如神经网络，可能存在多个局部极小值。实际上，这并不是一个严重的问题

	如果一个训练集可以唯一确定一组模型参数，则该模型称作可辨认的`identifiable`
	- 带有隐变量的模型通常是不可辨认的，因为可以批量交换隐变量，从而得到等价的模型（如交换隐单元 i 和 j 的权重向量）。这种不可辨认性称作权重空间对称性`weight space symmetry`
	- 我们可以放大权重和偏置 \\(\alpha\\) 倍，然后缩小传出权重 \\(\frac 1\alpha\\) 倍，从而保持模型等价

	模型可辨认性问题意味着：神经网络的代价函数具有非常多、甚至是无限多的局部极小解。
	- 由可辨认性问题产生的局部极小解都具有相同的代价函数值。它并不是非凸带来的问题
	- 如果局部极小解和全局极小解相差很大时，此时多个局部极小解会带来很大隐患。它将给基于梯度的优化算法带来极大问题
	- 实际中的网络，是否存在大量严重偏离全局极小解的局部极小解、优化算法是否会遇到这些局部极小解？这些都是未决的问题。
	- 目前学者们猜想：对于足够大的神经网络，大部分局部极小值都具有很小的代价函数值。我们是否找到全局极小值并不重要，我们只需要在参数空间中找到一个使得损失函数很小的点

2. 目前很多人将神经网络优化中的所有困难都归结于局部极小值。有一种方案是排除局部极小值导致的困难（说明是其他原因导致的困难）：绘制梯度范数随着时间的变化：
	- 如果梯度范数没有缩小到一个很小的值，则问题的原因既不是局部极小值引起的，也不是其他形式的临界点引起的
	- 如果梯度范数缩小到一个很小的值，则问题的原因可能是局部极小值引起的，也可能是其他原因引起的

### 2.3 高原、鞍点、其他平坦区域

1. 鞍点是另一类梯度为零的点
	- 对于很多高维非凸函数而言，鞍点数量远大于局部极值点
	- 鞍点附近的某些点比鞍点的值更大；鞍点附近的另一些点比鞍点的值更小。
	- 在鞍点处，黑塞矩阵同时具有正负特征值
		- 正特征值对应的特征向量方向的点，具有比鞍点更大的值
		- 负特征值对应的特征向量方向的点，具有比鞍点更小的值


2. 通常在低维空间中，局部极小值很普遍；在高维空间中，局部极小值很少见，鞍点更常见。

	- 对于函数 \\(f:\mathbb R^{n}\rightarrow \mathbb R\\)，鞍点和局部极小值的数量之比的期望随着 \\(n\\) 呈指数级增长。
	> 黑塞矩阵的特征值的正负号如果由抛硬币来决定的话，在一维情况下，很容易抛硬币得到正面向上；而在 \\(n\\) 维中，很难出现 \\(n\\) 次抛硬币都是正面向上

	- 当我们位于函数值较低的区间时，黑塞矩阵的特征值为正的可能性更大。这意味着：
		- 具有较大函数值的临界点更可能是鞍点
		- 具有较小函数值的临界点更可能是局部极小值点
		- 具有极高函数值的临界点更可能是局部极大值点

3. 鞍点对于训练算法的影响：
	- 对于只使用了梯度的一阶优化算法而言：情况不明。
		- 理论上，鞍点附近的梯度通常会非常小，导致梯度下降算法沿着梯度方向的步长非常小。
		- 实际上，梯度下降算法似乎在很多情况下都能够逃离鞍点。
	- 对于牛顿法而言，鞍点是个大问题。因为梯度下降的原则是：朝着下坡路的方向移动；而牛顿法的原则是：明确寻找梯度为零的点。
		- 如果不做任何修改，则牛顿法会主动跳入一个鞍点

4. 也可能出现一个恒值的平坦的宽区域。在这个区域中，梯度和黑塞矩阵都为零。

### 2.4 悬崖和梯度爆炸
1. 悬崖：斜率较大的区域。
	- 多层神经网络通常有像悬崖一样的区域
	- 产生悬崖的原因是：由于几个较大的权重相乘
	- 影响：在梯度更新时，如果遇到悬崖，则会导致步长非常大（因为此时梯度非常大），从而跨了非常大的一步，使得参数弹射的非常远。这样可能会使得已经完成的大量优化工作无效。

	下图是一个悬崖的例子：第二根路径就是由于遇到悬崖，导致参数更新的步长非常大。

	![悬崖](../imgs/8/explode.PNG)

2. 解决悬崖的问题是：使用启发式梯度截断策略（第十章）。
	- 梯度下降法只是指明了参数更新的方向（负梯度的方向），但是未指明最佳步长。
	- 当传统的梯度下降算法提议更新一大步时，启发式梯度截断会干涉并减小步长，从而使其基本上贴着悬崖来更新。如上图的第一根路径所示。

3. 在`RNN`网络的代价函数中，悬崖结构很常见。因为这一类模型会涉及到多个时间步长因素的相乘，导致产生了大量的相乘。

### 2.5 长期依赖
1. 当计算图非常深时，容易产生另一种优化困难。假设计算图中包含一条重复地、与矩阵 \\(\mathbf W\\) 相乘的路径。则经过 \\(t\\) 步之后，相当于与 \\(\mathbf W^{t}\\) 相乘。
	- 假设 \\(\mathbf W\\) 有特征值分解 \\(\mathbf W=\mathbf V diag(\mathbf{\vec \lambda})\mathbf V^{-1}\\)，则：
	$$ \mathbf W^{t}=\mathbf V diag(\mathbf{\vec \lambda})^{t}\mathbf V^{-1}$$
	其中
	$$
diag(\mathbf{\vec \lambda})=\begin{bmatrix}
\lambda_1&0&\cdots&0\\\
0&\lambda_2&\cdots&0\\\
\vdots&\vdots&\ddots&\vdots\\\
0&0&\cdots&\lambda_n
\end{bmatrix}
	$$
	- 考虑特征值 \\(\lambda_i\\)，当它不在 1 附近时：
		- 如果量级大于 1，则会爆炸（ \\(\lambda_i^{t}\\) 非常大）。这称作梯度爆炸问题`exploding gradient problem`
		- 如果量级小于 1，则会消失（ \\(\lambda_i^{t}\\) 非常小）。这称作梯度消失问题 `vanishing gradient problem`

2. 梯度爆炸使得学习不稳定。梯度消失使得学习难以进行：不知道参数向哪个方向移动从而改进代价函数。
	- 悬崖结构是梯度爆炸的一个例子

3. 循环网络在每个时间步上使用相同的矩阵 \\(\mathbf W\\)，因此非常容易产生梯度爆炸和梯度消失问题。
	- 前馈神经网络并没有使用相同的矩阵 \\(\mathbf W\\)，因此即使是非常深层的前馈神经网络也能很大程度上避免梯度爆炸和梯度消失问题

### 2.6 非精确梯度
1. 大多数优化算法都假设我们知道精确的梯度或者`Hessian`矩阵。实际中这些量都有躁扰，甚至是有偏的估计

2. 实际情况中，我们的目标函数是比较棘手的（难以用简洁的数学解析形式给出），此时梯度难以给出。这种情况下我们只能使用近似梯度。

3. 各种神经网络优化算法的设计都考虑到了梯度估计的不完美。
	- 我们可以选择比真实的损失函数更容易估计的替代损失函数来避免这个问题

### 2.7 局部和全局结构的弱对应
1. 对于最优化问题，如果克服了以上的所有困难，但是并没有到达代价函数低得多的区域，则表现仍然不佳。
	- 这就是局部优秀（跨过了鞍点，爬过了悬崖，克服了梯度消失...），全局不良（并未到达全局比较小的值所在的区域）

2. `Goodfellow et al.(2015)`认为：大部分训练的运行时间取决于：到达解决方案的轨迹的长度。

3. 大多数优化研究的难点集中于：训练是否到达了全局最小值、局部最小值、鞍点
	- 但是实践中，神经网络不会到达任何一种临界点。甚至不会到达梯度很小的区域。甚至这些临界点不是必然存在的
	> 如损失函数 \\(-\log p(y\mid \mathbf{\vec x};\vec\theta)\\) 没有全局极小点，而是趋向于某个极限值

	下图的例子说明：即使没有局部极小值和鞍点，还是无法使用梯度下降得到一个好的结果。原因是：初始化在山的左侧。
	- 左侧向左趋向于一条渐近线。此时梯度的负方向会不停向左来逼近这条渐进线
	- 理论上，优化算法要向右跨过山头，从而沿着右侧下降才能到达一个较低的函数值
	
	![local_global](../imgs/8/local_global.PNG)

4. 很多现有的研究方法在求解局部结构复杂的问题时，方法为寻求良好的初始化点，而不再是开发全局更新的算法

5. 局部梯度下降的问题：
	- 局部梯度下降或许能找出一条解路径，但是该路径包含了很多次更新。因此遵循该路径会带来很高的计算代价
	- 如果目标函数具有一个宽而平的区域，或者我们寻求一个精确的临界点，则局部下降无法定义解路径
	- 局部移动可能太过贪心，朝着梯度下降方向移动却远离了任何解决方案

	如果存在一个区域，我们遵循局部下降就能够合理地直接到达解决方案，并且我们初始化点就位于该区域，则上述问题都能够避免。

### 2.8 优化的理论限制
1. 我们为神经网络设计的任何优化算法都有性能限制。通常这些结果不影响神经网络在实践中的应用

2. 存在某类问题时不可解的。但是很难判断一个特定问题是否属于该类。

3. 神经网络训练中，我们通常不关注函数的精确极小值，而是关注将函数值下降到足够小，从而获得一个很好的泛化误差。
	- 关于优化算法能否到达这个目标的理论分析是极其困难的

## 3 基本算法
### 3.1 随机梯度下降 SGD
1. 随机梯度下降沿着随机挑选的`minibatch`数据的梯度下降方向，可以很大程度低加速
	- 随机梯度下降SGD及其变种可能是一般机器学习中用的最多的优化算法

2. 随机梯度下降中，参数的迭代更新：
	- 输入：学习率 \\(\epsilon\\)
	- 初始参数:\\(\vec\theta\_0\\)
	- 算法步骤：
		- 迭代，直到满足停止条件。迭代步骤为：
			- 从训练集中采样 \\(m\\) 个样本 \\(\\{\mathbf{\vec x}\_1,\mathbf{\vec x}\_2,\cdots,\mathbf{\vec x}\_m\\}\\) 构成`minibatch`。对应的标记为 \\(\\{y_1,y_2,\cdots,y_m\\}\\)
			- 计算`minibatch`上的梯度作为训练集的梯度的估计：
			$$\hat{\mathbf{\vec g}}\leftarrow \frac 1m \nabla\_{\vec\theta}\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta),y_i) $$
			- 更新参数：\\(\vec\theta \leftarrow \vec\theta-\epsilon\hat{\mathbf{\vec g}}\\)

2. `SGD`中一个关键参数是学习率。
	- 前面介绍的`SGD`使用固定的学习率 \\(\epsilon\\)
	- 实践中，有必要随着时间的推移而降低学习率。因此将第 \\(k\\) 步的学习率记做 \\(\epsilon\_k\\)

	原因是：使用标准的梯度下降到达极小值时，整个代价函数的真实梯度非常小，甚至为零。而`SGD`引入了噪源（使用`minibatch`的梯度作为整体梯度的估计），该噪源并不会在极小值处消失，使得在极小值时，梯度的估计可能会比较大。

	因此：标准的梯度下降可以使用固定的学习率，而`SGD`必须使用逐渐降低的学习率。

3. 对于学习率，保证`SGD`收敛的一个充分条件是：
	$$\sum\_{k=1}^{\infty}\epsilon\_k=\infty $$
	且：
	$$\sum\_{k=1}^{\infty}\epsilon\_k^{2}\lt \infty $$

	在实践中，一般采用线性衰减学习率到第 \\(\tau\\) 次迭代：
	$$ \epsilon\_k=\begin{cases}
	(1-\frac k\tau)\epsilon\_0+\frac k\tau\epsilon_\tau&,0\le k\le \tau\\\
	\epsilon\_{\tau}&,k\ge \tau
	\end{cases}$$
	其中 \\(\tau\\) 是预先指定的（如 1000）；\\(\epsilon\_0,\epsilon\_{\tau}\\) 为常数。
	- 学习率的选取可以通过试验和误差来选取。最好的选择方法是：画出目标函数值随着时间变化的学习曲线。
	- 参数选择为 \\(\epsilon_0,\epsilon\_{\tau},\tau\\)
		- \\(\tau\\) 被设置为训练了几百个样本所需要的迭代次数。（因此每一批训练的样本为 \\(m\\) 个，因此几百个样本可能需要若干批）
		- \\(\epsilon\_{\tau}\\) 通常被设置为 \\(\epsilon_0\\) 的大约 1%
		- 主要问题时如何选择  \\(\epsilon_0\\) 
			- 如果太大，则学习曲线将会剧烈震荡，代价函数值会明显增加。（温和的震荡市良好的）。
			- 如果太小，则学习过程会非常缓慢。
			- 如果太低，则学习可能会卡在一个相当高的函数值上
			- 通常最好检测最早的几轮迭代，使用一个高于此时效果最佳学习率的一个学习率，但是又不能太高以至于导致严重的不稳定性

	>学习速率的选择更像是一门艺术，而不是科学

4. `SGD`以及其它的`minibatch`算法的最重要性质是：每一步更新的计算时间（就是计算梯度的时间）不会随着训练样本数量的增加而增加。
	- 即使训练样本数量非常庞大时，算法也能收敛
	- 对于足够大的数据集，`SGD`可能在处理整个训练集的所有样本之前就收敛到测试集误差的允许范围之内了

5. 研究优化算法的收敛率，会衡量额外误差`excess error`：
	$$J(\vec\theta)-\min\_{\vec\theta}J(\vec\theta) $$
	- `SGD`应用于凸问题时， \\(k\\) 步迭代之后的额外误差量级时 \\(O(\frac{1}{\sqrt k})\\)，在强凸情况下是 \\(O(\frac 1k)\\)。除非给定额外条件，否则这些界限无法进一步改进
	- `Cramer-Rao`界限指出：泛化误差的下降速度不会快于  \\(O(\frac 1k)\\)
	- `Bottou and Bousquet`认定：对于机器学习任务，不值得探寻收敛快于  \\(O(\frac 1k)\\) 的优化算法。更快的收敛可能对应于过拟合
	
	本章中剩余介绍的大多数算法都实现了实践中的好处，但是丢失了常数倍  \\(O(\frac 1k)\\) 的渐进收敛率

6. 我们可以权衡标准梯度下降和`SGD`两者的优点，在学习过程中逐渐增大`minibatch`的大小

### 3.2 动量算法
1. `SGD`的问题时：有时候学习率会很慢。动量方法就是解决这一问题的。
	- 动量方法积累了之前梯度的指数级衰减的移动平均，然后继续沿着该方向移动（沿着动量的方向更新参数）
	>它是一种移动平均，权重是指数级衰减的：近期的权重较大，远期的权重很小。然后取这些加权梯度的均值。再根据该均值的方向决定参数的更新方向

2. 动量算法引入了变量 \\(\mathbf{\vec v}\\) 充当速度的角色：它刻画了参数在参数空间移动的方向和速度
	- 将负梯度看做参数空间中，移动粒子（就是参数 \\(\vec\theta\\)）的力。动量等于质量乘以速度。我们假设粒子是单位质量，因此速度等于动量。
	- 定义速度为负梯度的指数衰减平均，其更新规则为：
	$$\mathbf{\vec v}\leftarrow \alpha\mathbf{\vec v}-\epsilon\nabla\_{\vec\theta}\left(\frac 1m \sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta),y_i)\right)\\\
	\vec\theta\leftarrow \vec\theta+\mathbf{\vec v} $$
	- 超参数 \\(\alpha \in[0,1)\\) 描述了衰减系数的底数。
		- 衰减系数为 \\(\alpha,\alpha^{2},\alpha^{3},\cdots\\) 
		- \\(\alpha\\) 决定了之前的梯度衰减的有多快
		- \\(\alpha\\) 越大，则早期的梯度对当前的更新方向的影响越大

3. 下图给出了非动量的方法与动量方法的路径图。代价函数为一个二次函数，它的黑塞矩阵具有不良的条件数。
	- 红色路径表示动量方法的路径图
	- 黑色箭头给出了在该点，梯度下降（非动量方法）将采取的步骤

	可以看到：条件数较差的二次函数看起来就像一个长而窄的峡谷。动量能够正确地穿越峡谷；而梯度下降法会浪费大量的时间在峡谷的窄轴上来回移动。

	![momentum](../imgs/8/momentum.PNG)

4. 使用动量的`SGD`算法：
	- 输入：
		- 学习率 \\(\epsilon\\)
		- 动量参数 \\(\alpha\\)
		- 初始参数 \\(\vec\theta\_0\\)
		- 初始速度 \\(\mathbf{\vec v}\_0\\)
	- 算法步骤：
		- 迭代，直到满足停止条件。迭代步骤为：
			- 从训练集中采样 \\(m\\) 个样本 \\(\\{\mathbf{\vec x}\_1,\mathbf{\vec x}\_2,\cdots,\mathbf{\vec x}\_m\\}\\) 构成`minibatch`。对应的标记为 \\(\\{y_1,y_2,\cdots,y_m\\}\\)
			- 计算`minibatch`上的梯度作为训练集的梯度的估计：
			$$\hat{\mathbf{\vec g}}\leftarrow \frac 1m \nabla\_{\vec\theta}\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta),y_i) $$
			- 更新速度：\\(\mathbf{\vec v}\leftarrow \alpha\mathbf{\vec v}-\epsilon\hat{\mathbf{\vec g}} \\)
			- 更新参数：\\(\vec\theta \leftarrow \vec\theta+\mathbf{\vec v}\\)

5. 之前的步长只是梯度范数乘以学习率。采用动量之后，步长取决于梯度序列的大小、排列顺序、学习率。
	- 如果有许多连续的梯度指向相同的方向时，步长最大
	- 如果动量算法总是观测到了梯度 \\(\mathbf{\vec g}\\)，则它会在方向 \\(-\mathbf{\vec g}\\) 上不停地加速。直到最终的步长为：
	$$ \frac {\epsilon||\mathbf{\vec g}||}{1-\alpha}$$
	>通过求解速度序列： \\(\mathbf{\vec v}\_n=\alpha\mathbf{\vec v}\_{n-1}-\epsilon  \mathbf{\vec g} \\) 的解析表达式可以得到

6. 实践中， \\(\alpha\\) 取值一般为 0.5、0.9、0.99.
	- 和学习率一样， \\(\alpha\\) 也会随着时间变化。通常初始时采用一个较小的值，后面慢慢变大
	- 随着时间推移，改变 \\(\alpha\\) 没有收缩 \\(\epsilon\\) 更重要

### 3.3 Nesterov 动量
1. `Nesterove`动量时动量算法的变种，区别在于：
	- 计算`minibatch`的梯度时，采用更新后的参数 \\(\vec\theta+\alpha\mathbf{\vec v}\\) 。它可以视作向标准动量方法中添加了一个校正因子
	$$\mathbf{\vec v}\leftarrow \alpha\mathbf{\vec v}-\epsilon\nabla\_{\vec\theta}\left(\frac 1m \sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta+\alpha\mathbf{\vec v}),y_i)\right)\\\
	\vec\theta\leftarrow \vec\theta+\mathbf{\vec v} $$

2. 在凸`batch`梯度情况下，`Nesterov`动量将额外误差收敛率从 \\(O(\frac 1k)\\) 改进到 \\(O(\frac 1{k^{2}})\\) 。但是在随机梯度的情况下，`Nesterov`动量并没有改进收敛率

## 4. 参数初始化策略

1. 有些优化算法是非迭代的，可以直接解析求解最优解。有些优化算法是迭代的，但是它们是初始值无关的。
	- 深度学习不具有这两类性质，通常是迭代的，且与初始值相关。

2. 深度学习中，大多数算法都受到初始值的影响，它能决定算法最终是否收敛、以及收敛时的收敛速度有多快、以及收敛到一个代价函数较高还是较低的值。
	- 初始值也会影响泛化误差。

3. 目前选择初始化策略是启发式的。
	- 大多数初始化策略基于在神经网络初始化时实现一些良好的性质。但是这些性质能否在学习过程中保持，难以保证。
	- 有些初始化点从优化的观点是有利的，但是从泛化误差的观点来看是不利的
	- 设定一个好的初始化策略是困难的，因为神经网络优化任务至今都未被很好理解
	- 我们对初始点如何影响泛化误差的理解是相当原始的，几乎没有任何指导

4. 初始值的选择，目前唯一确定的特性是：需要在不同单元之间破坏对称性：
	- 如果具有相同激励函数的两个隐单元连接到相同的输入，则这些单元必须具有不同的初始化参数

	>- 如果他们具有相同的初始化参数，则非随机的学习算法将一直以同样的方式更新这两个单元
	>- 通常鼓励每个单元使用和其他单元不一样的函数（如选择不同的权重或者偏置），这样有助于没有输入模型丢失在前向传播的零空间中

5. 通常我们为每个单元的偏置 \\(\mathbf{\vec b}\\) 设置启发式挑选的常数，仅仅随机初始化权重 \\(\mathbf W\\)
	- 额外的参数也通过启发式挑选常数
	- 通常权重的初始化是从高斯分布或者均匀分布中挑选出来的值。
		- 从高斯分布还是均匀分布中挑选，看起来似乎没有很大差别，但是也没有被仔细研究
		- 但是该分布的范围（如均匀分布的上、下限）对优化结果和泛化能力有很大的影响

6. 初始权重的大小很重要。
	- 更大的初始权重具有更强的破坏对称性的作用，有助于避免冗余的单元
	- 更大的初始权重也有助于避免梯度消失
	- 更大的初始权重也容易产生梯度爆炸
	- 循环网络中，更大的初始权重可能导致混沌现象：对于输入中的很小的扰动非常敏感，从而导致确定性算法给出了随机性结果

	这些因素决定了权重的初始值的大小

7. 关于如何初始化网络，正则化和最优化有两种不同的角度：
	- 最优化角度建议权重应该足够大，从而能够成功传播信息
	- 正则化建议权重小一点（如 \\(L_2\\) 正则化），从而提高泛化能力

8. 有些启发式方法可用于选择权重的初始化大小。假设有 \\(m\\) 个输入， \\(n\\) 个输出的全连接层，其权重的启发式方法是从均匀分布 \\(U(-\frac{1}{\sqrt m},\frac{1}{\sqrt m})\\) 中采样权重
	- `Glorot et al.`建议使用归一化初始化
	$$ \mathbf W\_{i,j}\sim U\left(-\sqrt{\frac 6{m+n}},\sqrt{\frac 6{m+n}}\right) $$
	这种方法会初始化所有的层，使其在相同激励方差和相同的梯度方差之间折中
	- `Saxe et al.`建议初始化随机正交矩阵。然后仔细挑选负责每一层的非线性缩放因子 \\(g\\)。缩放因子 \\(g\\) 将网络推向网络前向传播时激励范数增加的区域；将网络推向网络反向传播时梯度范数增加的区域

9. 不幸的是，这些初始化权重的策略往往效果不佳。有三个可能的原因：
	- 我们可能使用了错误的标准：约束网络中信号（如梯度、权重）的范数可能并不会带来什么好处
	- 初始化时强加的性质可能在学习开始之后无法保持
	- 可能提高了优化速度，但意外地增大了泛化误差

	实践中，我们通常需要将初始权重范围视作超参数

10. 限定初始权重范围的缺点是：设置的所有的初始权重都具有相同的标准差（如 \\(\frac 1{\sqrt{m}}\\)），这使得层很大时，每个单一权重会变得非常小

	`Martens`提出了一种称作稀疏初始化的替代方案：每个单元初始化为恰好具有 \\(k\\) 个非零的权重
	- 这个方案有助于单元之间在初始化时就具有更大的多样性
	- 这个方案非常偏好于具有很大值的高斯值

11. 如果计算资源允许，你可以将每层权重的初始数值范围设置为一个超参数。然后使用超参数搜索算法来挑选这些超参数。

12. 偏置的初始化通常更容易。
	- 大多数情况下，可以设置偏置初始化为零
	- 有时我们可以设置偏置初始化为非零。这发生在下面的三种情况：
		- 如果偏置是作为输出单元，则初始化偏置为非零值
		- 有时选择偏置的初始值以免初始化引起太大的饱和
		- 有时某个单元作为开关来决定其他单元是使用还是不使用。此时偏置应该非零，从而打开开关。

13. 我们也可以使用机器学习来初始化模型的参数。
	- 在同样的数据集上，即使是用监督学习来训练一个不相关的任务，有时也能够得到一个比随机初始化更好的初始值。原因是：监督学习编码了模型初始参数分布的信息

	> 其他策略奏效的原因是：刚好找到了正确的参数初始值的范围，或者设置了不同单元计算互不相同的函数

## 5 具有自适应学习率的算法
1. 假设代价函数高度敏感于参数空间中的某些方向，那么我们希望每个参数设置不同的学习率。

2. `delta-bar-delta`算法是一个自适应学习率的算法。其基本思想是：对于代价函数，如果其偏导数保持相同的符号，则学习率应该增加；如果偏导数变化了符号，则学习率应该减小
	- 这种算法只能用于标准的梯度下降中（因为`minibatch`算法对于梯度的估计不是精确的，因此对于正负号的判断会出现较大偏差）

3. 对于`minibatch`优化，有一些自适应学习率的算法。下面介绍的都是。

### 5.1 AdaGrad
1. `AdaGrad`算法会独立的设置参数空间每个轴方向上的学习率。
	- 该方向的学习率反比于某个值的平方根，这个值就是该方向上所有梯度分量的历史平方值之和
	- 如果代价函数在某个方向上具有较大的偏导数，则这个方向上的学习率会相应降低；如果某个方向上具有较小的偏导数，则这个方向上的学习率会相应提高 

2. `AdaGrad`算法：
	- 输入：
		- 全局学习率 \\(\epsilon\\)
		- 初始参数 \\(\vec\theta\_0\\)
		- 小常数， \\(\delta\\)（为了数值稳定，大约为 \\(10^{-7}\\)）
	- 算法步骤：
		- 初始化梯度累计变量 \\(\mathbf{\vec r}=\mathbf{\vec 0}\\)
		- 迭代，直到停止条件。迭代步骤为：
			
			- 从训练集中采样 \\(m\\) 个样本 \\(\\{\mathbf{\vec x}\_1,\mathbf{\vec x}\_2,\cdots,\mathbf{\vec x}\_m\\}\\) 构成`minibatch`。对应的标记为 \\(\\{y_1,y_2,\cdots,y_m\\}\\)
			- 计算`minibatch`上的梯度作为训练集的梯度的估计：
			$$\hat{\mathbf{\vec g}}\leftarrow \frac 1m \nabla\_{\vec\theta}\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta),y_i) $$
			- 累计平方梯度： \\(\mathbf{\vec r}\leftarrow \mathbf{\vec r}+\hat{\mathbf{\vec g}}\odot\hat{\mathbf{\vec g}}\\)
			> \\(\odot\\) 表示两个向量的逐元素的相乘
			- 计算更新（逐元素）：
			$$ \Delta\vec\theta\leftarrow -\frac{\epsilon}{\delta+\sqrt{r}}\odot\hat{\mathbf{\vec g}}$$
			- 更新参数：\\(\vec\theta \leftarrow \vec\theta+\Delta\vec\theta\\)



3. 在凸优化中，`AdaGrad`算法效果较好。但是在训练深度神经网络模型中，实践中发现学习速率减小时机的过早，且减小的幅度过量。
	- `AdaGrad`算法在某些深度学习模型上效果不错，但不是全部

### 5.2 RMSProp
1. `RMSProp`是`AdaGrad`的一个修改：将梯度累计修改为指数加权的移动平均

2. 标准的`RMSProp`算法：
	- 输入：
		- 全局学习率 \\(\epsilon\\)
		- 衰减速率 \\(\rho\\)
		- 初始参数 \\(\vec\theta\_0\\)
		- 小常数， \\(\delta\\)（为了数值稳定，大约为 \\(10^{-6}\\)）
	- 算法步骤：
		- 初始化梯度累计变量 \\(\mathbf{\vec r}=\mathbf{\vec 0}\\)
		- 迭代，直到停止条件。迭代步骤为：
		 
			- 从训练集中采样 \\(m\\) 个样本 \\(\\{\mathbf{\vec x}\_1,\mathbf{\vec x}\_2,\cdots,\mathbf{\vec x}\_m\\}\\) 构成`minibatch`。对应的标记为 \\(\\{y_1,y_2,\cdots,y_m\\}\\)
			- 计算`minibatch`上的梯度作为训练集的梯度的估计：
			$$\hat{\mathbf{\vec g}}\leftarrow \frac 1m \nabla\_{\vec\theta}\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta),y_i) $$
			- 累计平方梯度： \\(\mathbf{\vec r}\leftarrow \rho\mathbf{\vec r}+(1-\rho)\hat{\mathbf{\vec g}}\odot\hat{\mathbf{\vec g}}\\)
			> \\(\odot\\) 表示两个向量的逐元素的相乘
			- 计算更新（逐元素）：
			$$ \Delta\vec\theta\leftarrow -\frac{\epsilon}{\delta+\sqrt{r}}\odot\hat{\mathbf{\vec g}}$$
			- 更新参数：\\(\vec\theta \leftarrow \vec\theta+\Delta\vec\theta\\)

3. 使用`Nesterove`动量的`RMSProp`算法：
	- 输入：
		- 全局学习率 \\(\epsilon\\)
		- 衰减速率 \\(\rho\\)
		- 动量系数 \\(\alpha\\)
		- 初始参数 \\(\vec\theta\_0\\)
		- 初始参数 \\(\mathbf{\vec v}\_0\\)
		 
	- 算法步骤：
		- 初始化梯度累计变量 \\(\mathbf{\vec r}=\mathbf{\vec 0}\\)
		- 迭代，直到停止条件。迭代步骤为：	
			- 从训练集中采样 \\(m\\) 个样本 \\(\\{\mathbf{\vec x}\_1,\mathbf{\vec x}\_2,\cdots,\mathbf{\vec x}\_m\\}\\) 构成`minibatch`。对应的标记为 \\(\\{y_1,y_2,\cdots,y_m\\}\\)

			- 计算临时更新： \\(\tilde {\vec\theta}\leftarrow \vec\theta+\alpha+\mathbf{\vec v}\\)
			- 计算`minibatch`上的梯度作为训练集的梯度的估计：
			$$\hat{\mathbf{\vec g}}\leftarrow \frac 1m \nabla\_{\tilde{\vec\theta}}\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\tilde{\vec\theta}),y_i) $$
			- 累计平方梯度： \\(\mathbf{\vec r}\leftarrow \rho\mathbf{\vec r}+(1-\rho)\hat{\mathbf{\vec g}}\odot\hat{\mathbf{\vec g}}\\)
			> \\(\odot\\) 表示两个向量的逐元素的相乘
			- 计算速度更新（逐元素）：
			$$ \mathbf{\vec v}\leftarrow \alpha\mathbf{\vec v}-\frac{\epsilon}{\sqrt{r}}\odot\hat{\mathbf{\vec g}}$$
			- 更新参数：\\(\vec\theta \leftarrow \vec\theta+\\mathbf{\vec v}\\)

4. `RMSProp`相比`AdaGrad`：
	- 引入了一个新的超参数 \\(\rho\\)，它控制了移动平均的长度范围
	- 经验证明：`RMSProp`是一种有效、实用的深度神经网络优化算法。目前它是深度学习业界经常采用的优化方法之一

### 5.3  Adam 
1. `Adam`来自于`Adaptive moments`，它是引入了动量的`RMSProp`算法。

2. `Adam`算法：
	- 输入：
		- 学习率 \\(\epsilon\\) ，建议默认为 0.001
		- 矩估计的指数衰减速率  \\(\rho_1,\rho_2\\) 在区间 \\([0,1)\\)。建议默认值分别为： 0.9 和 0.999
		- 用于数值稳定的小常数 \\(\delta\\) ，建议默认为 \\(10^{-8}\\)
		- 初始参数 \\(\vec\theta\_0\\)	 
	- 算法步骤：
		- 初始化一阶和二阶矩变量 \\(\mathbf{\vec s}=\mathbf{\vec 0,\mathbf{\vec r}=\mathbf{\vec 0}}\\)
		- 初始化时间步 \\(t=0\\)
		- 迭代，直到停止条件。迭代步骤为：	
			- 从训练集中采样 \\(m\\) 个样本 \\(\\{\mathbf{\vec x}\_1,\mathbf{\vec x}\_2,\cdots,\mathbf{\vec x}\_m\\}\\) 构成`minibatch`。对应的标记为 \\(\\{y_1,y_2,\cdots,y_m\\}\\)
			- 计算`minibatch`上的梯度作为训练集的梯度的估计：
			$$\hat{\mathbf{\vec g}}\leftarrow \frac 1m \nabla\_{\vec\theta}\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta),y_i) $$
			- \\(t\leftarrow t+1\\)
			- 更新有偏一阶矩估计： \\(\mathbf{\vec s}\leftarrow\rho\_1\mathbf{\vec s}+(1-\rho\_1)\hat{\mathbf{\vec g}}\\)
			- 更新有偏二阶矩估计： \\(\mathbf{\vec r}\leftarrow \rho\_2\mathbf{\vec r}+(1-\rho\_2)\hat{\mathbf{\vec g}}\odot\hat{\mathbf{\vec g}}\\)
			> \\(\odot\\) 表示两个向量的逐元素的相乘
			- 修正一阶矩的偏差：
			$$\hat{\mathbf{\vec s}}\leftarrow \frac{\mathbf{\vec s}}{1-\rho\_1^{t}}$$
			- 修正二阶矩的偏差：
			$$\hat{\mathbf{\vec r}}\leftarrow \frac{\mathbf{\vec r}}{1-\rho\_2^{t}}$$
			- 计算更新（逐元素）：
				$$\Delta\vec\theta=-\epsilon \frac{\hat{\mathbf{\vec s}}}{\sqrt{\hat{\mathbf{\vec r}}}+\delta} $$
			- 更新参数：\\(\vec\theta \leftarrow \vec\theta+\Delta\vec\theta\\)

3. 选择哪个算法并没有一个统一的共识：并没有哪一个算法表现的最好。
	- 目前流行的活跃使用的优化算法包括：`SGD`，具有动量的`SGD`，`RMSProp`，`AdaDelta`，`Adam`。
	- 选用哪个算法似乎主要取决于使用者对于算法的熟悉程度（以便调节超参数）

##6. 二阶近似方法
1. 为了简化问题，这里我们考察目标函数为经验风险函数（也就是没有考虑正则化项）：
	$$J(\vec\theta)=\mathbb E\_{\mathbf{\vec x},y\sim \hat p\_{data}(\mathbf{\vec x},y)}[L(f(\mathbf{\vec x};\vec\theta),y)]=\frac 1m\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta),y\_i) $$

### 6.1 牛顿方法
1. 牛顿法在某点 \\(\vec\theta\_0\\) 附近，利用二阶泰勒展开来近似 \\(J(\vec\theta)\\)：
	$$J(\vec\theta)\approx J(\vec\theta\_0)+(\vec\theta-\vec\theta\_0)^{T}\nabla\_{\vec\theta}J(\vec\theta\_0)+\frac 12(\vec\theta-\vec\theta\_0)^{T}\mathbf H(\vec\theta-\vec\theta\_0) $$
	- 其中 \\(\mathbf H\\) 为 \\(J\\) 对于 \\(\vec\theta\\) 的海森矩阵在 \\(\vec\theta\_0\\) 处的值
	- 如果求解这个函数的临界点（梯度为零），则得到牛顿法的更新规则：
	$$\vec\theta^{\*}=\vec\theta\_0-\mathbf H^{-1}\nabla\_{\vec\theta}J(\vec\theta\_0) $$
		- 如果 \\(J\\) 为 \\(\vec\theta\\) 的二次函数（且具有正定的 \\(\mathbf H\\)），则牛顿法会直接跳到极小值
		- 如果 \\(J\\) 为高阶的，则需要迭代

2. 牛顿法：
	- 输入： 
		- 初始参数 \\(\vec\theta\_0\\)
		- 包含 \\(m\\) 个样本的训练集
	- 算法步骤：
		- 迭代，直到到达停止条件。迭代步骤为：
			- 计算梯度：
				$$\mathbf{\vec g}\leftarrow \frac 1m\nabla\_{\vec\theta}\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta),y\_i) $$
			- 计算海森矩阵
				$$\mathbf H\leftarrow \frac 1m\nabla^{2}\_{\vec\theta}\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta),y\_i) $$
			- 计算海森矩阵的逆矩阵： \\(\mathbf H^{-1}\\)
			- 计算更新： \\(\Delta\vec\theta=-\mathbf H^{-1}\mathbf{\vec g}\\)
			- 应用更新： \\(\vec\theta=\vec\theta+\Delta\vec\theta\\)

3. 只要海森矩阵保持正定，则牛顿法就能够迭代的使用。
	- 在深度学习中，目标函数具有很多鞍点，因此使用牛顿法是有问题的：海森矩阵的特征值并不全为正的。在靠近鞍点附近，牛顿法会导致更新朝着错误的方向移动
	- 解决的办法是：使用正则化的海森矩阵。常用的正则化策略是：在海森矩阵的对角线上增加常数 \\(\alpha\\)。于是更新过程为：
	$$\vec\theta^{\*}=\vec\theta\_0-[\mathbf H+\alpha\mathbf I]^{-1}\nabla\_{\vec\theta}J(\vec\theta\_0) $$
		- 这个正则化策略是牛顿法的近似
		- 只要海森矩阵的负特征值移动到靠近零点，则就有效果
		- 如果 \\(\alpha\\) 增大到一定程度，则海森矩阵就变得由对角矩阵 \\(\alpha\mathbf I\\) 主导。此时：牛顿法选择的方向就是 \\(\frac 1\alpha\mathbf{\vec g}\\)
		- 当有很强的负曲率存在时， \\(\alpha\\) 可能特别大

4. 海森矩阵的元素的数量是参数数量的平方。如果参数数量为 \\(n\\)，则牛顿法需要计算 \\(n\times n\\) 矩阵的逆，计算复杂度为 \\(O(n^{3})\\)
	- 由于参数每次更新时都将改变，因此每轮迭代训练都需要计算海森矩阵的逆矩阵
	- 因此只有参数很少的网络才能够在实际中应用牛顿法训练 

### 6.2 共轭梯度
1. 共轭梯度通过迭代下降的共轭方向来避免求解海森矩阵的逆矩阵

2. 在最速下降法中，假设上一次搜索方向是 \\(\mathbf{\vec d}\_{t-1}\\)，当前搜索方向是  \\(\mathbf{\vec d}\_{t}\\)。可以证明有：
	$$\mathbf{\vec d}\_{t} \cdot  \mathbf{\vec d}\_{t-1}=0$$
	即：前后两次搜索的方向是正交的
	> 最速下降法：
	>
	>- 在第 \\(k\\) 步：已知 \\(\vec\theta\_k\\) 的梯度 \\(\mathbf{\vec g}\_k\\)，现在需要求 $$\min\_{\lambda} f(\vec\theta\_k-\lambda\mathbf{\vec g}\_k)$$
	>- 则 $$0=\frac{\partial f}{\partial \lambda}=-\nabla f(\vec\theta\_k-\lambda\mathbf{\vec g}\_k)\cdot \mathbf{\vec g}\_k \\\
	 \rightarrow \nabla f(\vec\theta\_{k+1})\cdot \mathbf{\vec g}\_k=0\\\
	\rightarrow   \mathbf{\vec g}\_{k+1}\cdot \mathbf{\vec g}\_k=0$$

3. 在最速下降法中，前进过程是锯齿形的。
	- 我们在某种意义上，消除了之前的线性搜索方向上取得的进展

4. 共轭梯度的搜索方向会保持前一次线性搜索方向上取得的进展：
	$$\mathbf{\vec d}\_t=\nabla\_{\vec\theta} J(\vec\theta)+\beta\_t\mathbf{\vec d}\_{t-1}$$
	其中 \\(\beta\_t\\) 的大小控制了：我们想保留多大比例的上一次搜索方向到本次搜索方向

5. 如果 \\(\mathbf{\vec d}\_t\mathbf H\mathbf{\vec d}\_{t-1}=0\\)，则称 \\(\mathbf{\vec d}\_t,\mathbf{\vec d}\_{t-1}\\) 是共轭的，其中 \\(\mathbf H\\) 为海森矩阵

6. 要想选择 \\(\beta\_t\\)，最直接的方法是根据 \\(\mathbf{\vec d}\_t\mathbf H\mathbf{\vec d}\_{t-1}=0\\) 来计算
	- 直接计算也需要计算海森矩阵的逆矩阵，比较复杂
	- 有两个计算 \\(\beta\_t\\) 的流行方法（不需要计算海森矩阵的逆矩阵）：
		- `Fletcher-Reeves`：
		$$\beta_t=\frac{\nabla\_{\vec\theta}J(\vec\theta\_{t})^{T}\nabla\_{\vec\theta} J(\vec\theta\_{t})}{\nabla\_{\vec\theta}J(\vec\theta\_{t-1})^{T}\nabla\_{\vec\theta}J(\vec\theta\_{t-1})} $$
		- `Polak_Ribiere`：
		$$\beta_t=\frac{(\nabla\_{\vec\theta}J(\vec\theta\_{t})-\nabla\_{\vec\theta}J(\vec\theta\_{t-1}))^{T}\nabla\_{\vec\theta} J(\vec\theta\_{t})}{\nabla\_{\vec\theta}J(\vec\theta\_{t-1})^{T}\nabla\_{\vec\theta}J(\vec\theta\_{t-1})} $$

7. 如果前一次搜索已经找出了某个方向上的最小值，最速下降法不会保持这一方向。
	- 对于二次函数，共轭方向会保持前一次方向以及大小（因此在前一个方向上仍然是极小值）。其结果是：在 \\(k\\) 维参数空间中，共轭梯度最多需要 \\(k\\) 次线性搜索就能到达极小值

8. 共轭梯度法：
	- 输入：
		- 初始参数 \\(\vec\theta\_0\\)
		- 包含 \\(m\\) 个样本的训练集
	- 算法步骤：
		- 初始化：
		$$ \vec\rho\_0=\mathbf{\vec 0},\mathbf{\vec g}\_0=\mathbf{\vec 0},t=1$$
		- 迭代，直到到达停止条件。迭代步骤为：
			- 计算梯度：
				$$\mathbf{\vec g}\_t\leftarrow \frac 1m\nabla\_{\vec\theta}\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta),y\_i) $$
			- 计算 \\(\beta\_t\\)
				$$\beta_t=\frac{(\mathbf{\vec g}\_t-\mathbf{\vec g}\_{t-1})^{T}\mathbf{\vec g}\_t}{\mathbf{\vec g}\_{t-1}^{T}\mathbf{\vec g}\_{t-1}} $$
			> 如果是非线性共轭梯度：则可以（如当 t 是 5的倍数，也可以是某个其他数的倍数）重置 \\(\beta\_t\\) 为零
			- 计算搜索方向： \\(\vec\rho\_t=-\mathbf{\vec g}\_t+\beta\_t\vec\rho\_{t-1}\\)
			- 执行线性搜索： \\(\epsilon^{\*}=\arg\min\_{\epsilon}\frac 1m\sum\_{i=1}^{m}L(f(\mathbf{\vec x}\_i;\vec\theta\_t+\epsilon\vec\rho\_t),y\_i)\\)
			> 对于真正的二次函数：存在 \\(\epsilon^{\*}\\) 的解析解，无需显式搜索
			- 应用更新： \\(\vec\theta\_{t+1}=\vec\theta\_t+ \epsilon^{\*}\vec\rho\_t\\)
			- \\(t\leftarrow t+1\\)

9. 神经网络的目标函数比二次函数复杂得多，但是共轭梯度法在这种情况下仍然适用
	- 如果不是二次的，则共轭方向也不再保证在以前方向上，目标函数仍然取极小的。因此：非线性共轭梯度算法会偶尔采取一些重置操作（重置 \\(\beta\_t\\) 为零）
	- 尽管共轭梯度算法是批方法（需要所有的样本来计算梯度），目前也开发出了`minibatch`版本

### 6.3 BFGS 
1. `BFGS`算法具有牛顿法的一些优点，但是没有牛顿法的计算负担
	- 大多数拟牛顿法（包括 `BFGS`）采用矩阵 \\(\mathbf M\_t\\) 来近似海森矩阵的逆矩阵
	- 当 \\(\mathbf M\_t\\) 更新时，下降方向为 \\(\vec\rho\_t=\mathbf M\_t\mathbf{\vec g}\_t\\)。在该方向上的线性搜索的最佳步长为 \\(\epsilon^{\*}\\)，则参数更新为：
	$$\vec\theta\_{t+1}=\vec\theta\_t+\epsilon^{\*}\vec\rho\_t $$

2. `BFGS`算法迭代了一系列线性搜索，其方向蕴含了二阶信息
	- 与共轭梯度不同，`BFGS`的成功并不需要线性搜索真正的找到该方向上接近极小值的一点。因此`BFGS`在每个线性搜索上花费更少的时间
	- `BFGS`算法必须存储海森矩阵逆矩阵的近似矩阵 \\(\mathbf M\_t\\)，需要 \\(O(n^{2})\\) 的存储空间。因此`BFGS`不适用于大多数具有百万级参数的现代深度学习模型

3. `L-BFGS`通过避免存储完整的海森矩阵的逆的近似矩阵 \\(\mathbf M\_t\\) 来降低存储代价
	- `L-BFGS`起始假设 \\(\mathbf M\_0\\) 为单位矩阵，每步存储一些用于更新 \\(\mathbf M\\) 的向量，并且每一步的存储代价是 \\(O(n)\\)

## 7 优化策略和元算法
1. 有些优化技术并不是真正的算法，而是一个模板，它可以产生特定的算法

### 7.1 batch normalization
1. `batch normalization`是优化神经网络的一大创新。
	- 它并不是一个优化算法，而是一个自适应的、调整参数模型的方法
	- 它试图解决训练非常深的神经网络的困难

2. 对于一个深层的神经网络，如果我们同时更新所有层的参数，则可能会发生一些意想不到的后果

	假设有一个深层神经网络，每层只有一个单元，且每个隐层不使用激励函数。则输出为：
	$$\hat y=xw_1w_2\cdots w_l $$
	其中 \\(w_i\\) 为第 \\(i\\) 层的权重。第 \\(i\\) 层的输出为： \\(h_i=h\_{i-1}w_i\\)
	- 输出 \\(\hat y\\) 是输入 \\(x\\) 的线性函数，但是是权重 \\(w_i\\) 的非线性函数（因为有交叉乘积项）
	- 梯度为 \\(\mathbf{\vec g}=\nabla\_{\mathbf{\vec w}}\hat y\\)

	在使用梯度下降法更新参数时，使用：
	$$ \mathbf{\vec w}\leftarrow  \mathbf{\vec w}-\epsilon  \mathbf{\vec g}$$
	- 如果我们使用 \\(\hat y\\) 的一阶泰勒近似，则有：
	$$f(\mathbf{\vec w}-\epsilon  \mathbf{\vec g})-f(\mathbf{\vec w})\approx-\epsilon \mathbf{\vec g}^{T}\mathbf{\vec g} $$
	即：\\(\hat y\\) 的值下降了 \\(\epsilon \mathbf{\vec g}^{T}\mathbf{\vec g}\\)

	- 如果我们希望 \\(\hat y\\) 下降 0.1，则我们应该设置学习率为 \\(\frac{0.1}{\mathbf{\vec g}^{T}\mathbf{\vec g}}\\)
	- 但是实际上考虑二阶、三阶甚至更高阶的项，有：
		$$ f(\mathbf{\vec w}-\epsilon  \mathbf{\vec g})-f(\mathbf{\vec w})=x(w_1-\epsilon g_1)(w_2-\epsilon g_2)\cdots (w_l-\epsilon g_l)-xw_1w_2\cdots w_l\\\
	= -\epsilon x \sum\_{i=1}^{l}\left(g_i\prod\_{j=1,j\ne i}^{l}w_j\right)+\epsilon^{2} x \sum\_{i=1}^{l}\sum\_{j=i}^{l}\left(g_ig_j\prod\_{k=1,k\ne i,k\ne j}^{l}w_j\right)+\cdots $$
	考虑到 \\(g_i=\prod\_{j=1,j\ne i}^{l}w_j\\)，则有：
		$$ f(\mathbf{\vec w}-\epsilon  \mathbf{\vec g})-f(\mathbf{\vec w})=-\epsilon \mathbf{\vec g}^{T}\mathbf{\vec g}+\epsilon^{2} x \sum\_{i=1}^{l}\sum\_{j=i}^{l}\left(g_ig_j\prod\_{k=1,k\ne i,k\ne j}^{l}w_j\right)+\cdots  $$
	如果 \\(w_i\\) 都比较小，则  \\(\prod\_{k=1,k\ne i,k\ne j}^{l}w_j\\) 很小，则二阶项可以忽略不计；如果  \\(w_i\\) 都比较大，则该二阶项可能会指数级大。

	- 此时很难选择一个合适的学习率：因为某一层中参数更新的效果会取决于其他所有层（即其它层的权重是不是较大）
	- 虽然二阶优化算法会利用二阶项的相互作用来解决这个问题，但是还有三阶项甚至更高阶项的影响

3. `batch normalization`解决了多层之间协调更新的问题，他可以应用于网络的任何输入层或者隐层。

	设 \\(\mathbf H\\) 是`minibatch`某中间层的一个输出。我们定义该矩阵为：每个样本出现在该矩阵的一行中（而不是按列的）。我们将该矩阵标准化为：
	$$ \mathbf H^{\prime}=\frac{\mathbf H-\vec\mu}{\vec\sigma}$$	
	其中：
	$$\vec\mu=\frac 1m\sum\_{i}\mathbf H\_{i,:}\\\
	\vec\sigma=\sqrt{\delta+\frac 1m\sum\_i(\mathbf H-\vec\mu)\_i^{2}}
	$$
	这里 \\(\vec\mu\\) 是包含每列均值的向量； \\(\vec \sigma\\) 是包含每列标准差的向量， \\(\delta\\) 是一个很小的正值（比如 \\(10^{-8}\\)），以避免遇到 \\(\sqrt z\\) 的梯度在 \\(z=0\\) 处未定义的问题。这里的算术运算是基于广播运算。

	然后在网络的其余部分，对 \\(\mathbf H^{\prime}\\) 的操作和 \\(\mathbf H\\) 一样。

4. `batch normalization`之后，梯度下降法不会再简单地增加 \\(h_i\\) 的标准差或者均值，因为标准化操作会使其均值为零、标准差为1。
	- 有些策略会通过添加罚项来鼓励 \\(h_i\\) 的方差为1。但是这种方法会导致不完全的标准化
	- 有些策略会在每个梯度下降步骤之后进行标准化。这种策略会显著的消耗时间

5. 在测试阶段，如果我们对单一样本评估时（此时测试集只有单个样本，无法给出均值和标准差），我们可以将 \\(\vec\mu,\vec\sigma\\) 设置为训练阶段收集的运行均值。

6. 回顾例子 \\(\hat y=xw_1w_2\cdots w_l\\) 。假设 \\(x\\) 来自一个标准的高斯分布（均值为0，方差为1），那么 \\(h\_{l-1}\\) 也是一个高斯分布（因为 \\(x\\) 到 \\(h\_{l-1}\\) 是线性变换）
	- 但是 \\(h\_{l-1}\\) 不再是单位方差
	- 经过`batch normalization`之后， 经过标准化之后的 \\(\hat h\_{l-1}\\) 是单位方差。此时输出 \\(\hat y=w\_l\hat h\_{l-1}\\)
	- 这时较低层的参数在大多数情况下都没有什么影响：它们的串联的输出( 即 \\(h\_{l-1}\\) )最终总是重新标准化为单位高斯分布
		- 极少数情况，比如当某个权重为 0、或者权重的符号发生改变时，才会产生不同的输出
	- 如果不采用`batch normalization`，则几乎每一层的权重都对 \\(h\_{l-1}\\) 的统计量（均值、方差）有着重要影响（这就使得每一层的每次参数更新都对着 \\(h\_{l-1}\\) 有重要影响）；但是采用 `batch normalization`之后，这种影响被人为解除。这使得`batch normalization`显著地使得模型易于学习
	- 对于线性网络，采用`batch normalization`后，较低层不再有任何有害的影响，但是也不会有任何有益的影响（也就是没有任何影响）。这时因为我们标准化了一阶统计量（均值）和二阶统计量（方差）。这两者是线性网络可以影响的所有因素。
	- 对于非线性网络，采用`batch normalization`后，由于较低层可以进行非线性变换（使用了非线性激励函数），因此较低层仍然是有用的
	- 由于网络的最后一层能够学习线性变换，因此实际上我们可以移除那些除了最后一层之外的所有层的单元之间的线性关系。但是消除所有的线性关系比`batch normalization`代价更高。因此它也不如`batch normalization`更实用

7. 标准化一个单元的均值和标准差会降低包含该单元的神经网络的表达能力
	- 为了保持网络的表达能力，通常会修改`batch normalization`为：
		$$\mathbf H^{\prime\prime}=\gamma\mathbf H^{\prime}+\beta $$
	而不是简单地使用标准化的 \\(\mathbf H^{\prime}\\)
	- 变量 \\(\beta,\gamma\\) 是我们允许新变量的均值和标准差参数
	- 虽然 \\(\mathbf H^{\prime\prime}\\) 不再是零均值和单位方差的，但是它保证了 \\(\mathbf H^{\prime\prime}\\)  的均值和方差不再依赖于较低层的单元。这就使得这两个新参数很容易通过梯度下降来学习

8. 大多数神经网络隐层采用 \\(\phi(\mathbf X\mathbf W+\mathbf{\vec b})\\) 的形式。其中： \\(\phi\\) 是非线性激励函数（如`relu`）
	- 推荐对 \\(\mathbf X\mathbf W+\mathbf{\vec b}\\) 进行 `batch normalization`（而不是 \\(\mathbf X\mathbf W\\) ），因为参数 \\(\beta\\) 会加入`batch normalization`

### 7.2 坐标下降
1. 如果我们最小化 \\(f(\mathbf{\vec x})\\)：
	- 我们可以先相对于单一变量 \\(x_i\\) 最小化
	- 然后相对于另一个变量 \\(x_j\\) 最小化....
	- 如此反复循环所有的变量，我们会保证到达（局部）极小值

	这种做法被称作坐标下降。还有一种块坐标下降：它对于某个子集的变量同时最小化。

2. 当优化问题中的不同变量能够清晰地划分为相对独立的组，或者优化一组变量明显比优化所有变量的效率更高时，坐标下降最有意义

3. 考虑稀疏编码问题：目标是寻求一个权重矩阵 \\(\mathbf W\\)，它可以通过线性解码字典矩阵 \\(\mathbf H\\) 以重构训练集 \\(\mathbf X\\) ；其中要求字典矩阵  \\(\mathbf H\\) 尽量稀疏 。代价函数：
	$$J(\mathbf H,\mathbf W)=\sum\_{i,j}|\mathbf H\_{i,j}|+\sum\_{i,j}(\mathbf X-\mathbf W^{T}\mathbf H)
_{i,j}^{2} $$
	- 函数 \\(J\\) 不是凸的。但是我们可以将输入分成两个集合：权重 \\(\mathbf W\\) 和字典 \\(\mathbf H\\)。
	- \\(J\\) 关于权重 \\(\mathbf W\\) 是凸的； \\(J\\) 关于字典 \\(\mathbf H\\) 也是凸的。 因此：我们可以使用块坐标下降（其中可以使用高效的凸优化算法），交替固定 \\(\mathbf H\\) 优化 \\(\mathbf W\\) 以及固定 \\(\mathbf W\\)  优化 \\(\mathbf H\\) 

4. 当一个变量值很大程度影响另一个变量的最优值时，坐标下降不是个好办法：
	$$f(\mathbf{\vec x})=(x_1-x_2)^{2}+\alpha(x_1^{2}+x_2^{2}) $$
	- 第一项鼓励两个变量具有相近的值；第二项鼓励它们接近零。牛顿法可以一步解决该问题（它是一个正定二次问题），解为零
	- 对于较小的 \\(\alpha\\)（此时函数值由第一项决定），坐标下降法非常缓慢。因为第一项不允许两个变量相差太大。

### 7.3 Polyak 平均
1. 假设 \\(t\\) 次迭代，梯度下降的迭代路径为 \\(\theta^{(1)},\theta^{(1)},\cdots,\theta^{(t)}\\)，则`Polyak`平均算法的输出为：
	$$\hat \theta^{(t)}=\frac 1t\sum\_{i}\theta^{(i)}$$

	- 对于凸问题，该方法具有较强的收敛保证
	- 对于神经网络，这是一种启发式方法。但是实践中表现良好
	- 其基本思想是：优化算法可能来回穿过山谷而没有落在山谷底部。因此可以考虑路径的均值来平滑输出

2. 在非凸问题中，优化轨迹的路径可能非常复杂。因此当`Polyak`应用于非凸问题时，通常会使用指数衰减来计算平均值：
	$$\hat \theta^{(t)}=\alpha \hat\theta^{(t-1)}+(1-\alpha)\theta^{(t)}$$
	- 这个计算均值的方法被用于大量数值应用中

### 7.4 监督预训练

1. 有时模型太复杂难以优化，直接训练模型可能太过于困难。此时可以训练一个较简单的模型，然后使模型复杂化来求解原始问题。
	- 在直接训练目标模型求解目标问题之前，训练简单模型求解简化问题的方法统称为预训练

2. 贪心算法将问题分解为许多部分，然后独立地在每个部分求解最优值
	- 但是结合各个最佳部分并不能保证得到一个最佳的完整解。
	- 贪心算法计算上要比求解最优联合解的算法高效得多，并且贪心算法的解在不是最优的情况下，往往也是可以接受的
	- 贪心算法可以跟随一个微调步骤。此步骤会搜索全问题的最优解，提高找到的解的质量

3. 预训练（尤其是贪心预训练）在深度学习中是普遍存在的。
	- 我们将监督学习问题分解成简化的监督学习问题的预训练算法，这称作：贪心监督预训练

4. 贪心监督预训练的一个例子如下图所示：
	- 我们先训练一个最简单的架构，只有一个隐层（如图 a 所示。图 b 是另一个画法）。
	- 然后我们将第一个隐层的输出 \\(h^{(1)}\\) 作为输入，再添加一个隐层，来训练 \\(h^{(1)}\rightarrow W^{(2)}\rightarrow h^{(2)}\rightarrow U^{(2)}\rightarrow y\\)
	- 然后我们将第二个隐层的输出作为输入，再添加一个隐层，训练....
	- 在这个过程中，前一步训练的隐层的输出作为输入
	- 最后为了进一步优化我们可以联合微调所有层

	![greedy](../imgs/8/greedy.PNG)

5. 贪心监督预训练有效的原因，`Bengio et al.`提出的假说是：它有助于更好地指导深层结构的中间层的学习
	- 通常，预训练在优化和泛化这两方面都是有帮助的
	- 中间层的知识能够有助于训练神经网络

### 7.5 选择有助于优化的模型

1. 改进优化的最好方法是选择一个好的模型
	- 深度模型中，优化的许多改进来自于易于优化的模型
	- 选择一族容易优化的模型比使用一个强大的优化算法更重要
	- 神经网络过去30年大多数进步主要来自于改变模型族，而不是优化算法
	- 1980年代的带动量的随机梯度下降，依然是当前神经网络应用中的前沿算法

2. 现代神经网络更多使用线性函数，如`relu`何`maxout`单元

### 7.6 连续方法和课程学习

1. 许多优化挑战都来自于我们并不知道代价函数的全局结构，从而不知道最优解所在的区域。
	- 解决该问题的主要方法是：尝试初始化参数到某个区域内，该区域可以通过局部下降很快连接到参数空间中的解

2. 连续方法的原理：挑选一系列的初始化点，使得局部优化发生在变现良好的区域。方法为：构造一系列具有相同参数的目标函数 \\(\\{J^{(0)}(\theta),J^{(1)}(\theta),\cdots,J^{(n)}(\theta)\\}\\)
	- 这些代价函数逐步提高难度，其中 \\(J^{(0)}\\) 是最容易优化的
	- 前一个代价函数的解是下一个的初始化点
	- 这样我们首先解决一个简单的问题，然后改进解来解决逐步变难的问题，直到我们求解真正问题的解

3. 传统的连续方法（非神经网络的）通常是基于平滑的目标函数，主要用于克服局部极小值的问题。
	- 它被设计为：在有许多局部极小值的情况下，求解一个全局极小值
	- 这些连续方法通过“模糊”原始的代价函数来构建更加容易的代价函数。这种模糊操作可以用采样来近似：
		$$J^{(i)}(\theta)=\mathbb E\_{\theta^{\prime}\sim \mathcal N(\theta^{\prime};\theta,\sigma^{(i)2})} J(\theta^{\prime}) $$
	- 其背后思想是：某些非凸函数，在模糊之后会近似凸的。
	- 通常，这种模糊保留了关于全局极小值的足够多的信息，我么可以通过逐步求解更少模糊的问题来求解全局极小值
	- 这种方法有三种失败的可能：
		- 可能需要非常多的代价函数，导致整个过程的成本太高
		- 不管如何模糊，可能函数还是没有办法变成凸的
		- 函数可能在模糊之后，最小值会逐步逼近到一个局部极小值，而不是原始代价函数的全局极小值

4. 对于神经网络，局部极小值已经不是神经网络优化中的主要问题。但是连续方法仍然有所帮助。
	- 连续方法引入的简化的目标函数能够消除平坦区域，减少梯度估计的方差，提高海森矩阵的条件数，使得局部跟新更容易计算，或者改进局部更新方向朝着全局解

5. `Bengio et al.`指出：课程学习的方法可以解释为连续方法
	- 课程学习的思想是：首先学习简单概念，然后逐步学习依赖于这些简化概念的复杂概念
	- `Bengio et al.`验证了课程学习为连续方法
	- 课程学习已经成功地应用于大量的自然语言和计算机视觉任务上 