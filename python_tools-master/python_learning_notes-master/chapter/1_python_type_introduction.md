动态类型是Python多态的基础，因为没有类型约束。Python的多态是`x.method`的方法运行时，`method`的意义取决于`x`的类型，**<font color='red'>属性总是在运行期解析</font>**

八/十六/二进制整数：`0o177`（小写的字符`o`或者大写的`O`），`0x9ff`，`0b101010`

`hex(intx)`、`oct(intx)`、`bin(intx)`、`str(intx)`将整数`intx`转换成十六/八/二/十进制表示的字符串

`int(strx,base)`将字符串`strx`根据指定的`base`进制转换成整数。`base`默认为10

.Python允许执行连续比较，且比较链可以任意长：

* `a<b<c`结果等同于`a<b and b<c`
* `a<b>c`结果等同于`a<b and b>c`

.Python中的布尔类型为`bool`，它只有两个值`True`和`False`。  
`True`和`False`是预定义的内置变量名，其在表达式中的行为与整数1和0是一样的。实际上他们就是内置的`int`类型的子类。



3.`set`对象有以下操作：

* 成员关系：`e in x`(返回`bool`值）

* 差集： `x-y`（返回新的`set`对象）

* 并集： `x|y`（返回新的`set`对象）

* 交集： `x&y`（返回新的`set`对象）

* 对称差集： `x^y`（返回新的`set`对象）

  >对称差集：并集中去掉交集的那部分

* 判定x是否是y的超集： `x>y`(返回`bool`值）

* 判定x是否是y的子集：`x<y`(返回`bool`值）  

3.`set`的方法有：

* `.add(item)`：向`set`中插入一项，原地修改（返回`None`)。其中`item`为待插入项
* `.update(iter)`：求并集，原地修改（返回`None`)。其中`iter`为任何可迭代对象
* `.remove(item)`：向`set`中删除一项，原地修改（返回`None`)。其中`item`为待删除项
* `.intersection(iter)`：求交集，返回新的`set`对象。其中`iter`为任何可迭代对象

4.`set`对象是可迭代的，因此可用于`len()`函数，`for`循环，以及列表解析中，但是因为是无序的所以不支持索引和分片操作。



* `.pop()`方法：删除末尾元素并返回该元素，<font color="red">原地修改</font>
  * `.pop(index)`方法：删除指定位置元素并返回该元素，
    <font color="red">原地修改</font>
* `.remove(val)`：通过值删除元素，**若有多个值，则只删除第一个遇到的值**
  <font color="red">原地修改</font>
* `.insert(index,val)`：在指定位置插入元素，<font color="red">原地修改</font>
* `.index(val)`：返回指定元素的位置，**若有多个值，则只返回第一个遇到的值所在位置**



* `.index(val)`方法：在元组中搜索`val`值所在位置
* `.count(val)`方法：在元组中累计`val`值出现的次数

3.`set`不是序列，它是可变对象，但是元素只能是不可变类型。字典也不是序列，它是可变对象，其元素的值是不限类型，但是键必须是不可变类型。

比较操作时，Python能够自动遍历嵌套的对象，从左到右递归比较，要多深有多深。过充中首次发现的差异将决定比较的结果。 



* 字典的迭代：
  * `d.keys()`：返回一个dict_keys对象，它是一个可迭代对象，迭代时返回键序列
  * `d.values()`：返回一个dict_values对象，它是一个可迭代对象，迭代时返回值序列
  * `d.items()`：返回一个dict_items对象，它是一个可迭代对象，
    迭代时返回元组`(键，值)`的序列
* 获取键的值：通过`d.get(key,default_value)`。返回键对应的值，	若键不存在则返回
  `default_value`
* 字典的操作：
  * `d1.update(d2)`：合并两个字典，原地修改`d1`字典
  * `d.pop(key)`： 从字典中删除`key`并返回该元素的值
  * `del d[key]`：从字典中删除`key`但是不返回该元素的值
  * `d[key]=value`：原地的添加/修改字典。当向不存在的键赋值时，相当于添加新元素

* `d.keys()`、`d.values()`、`d.items()`返回的是可迭代对象，他们称为视图对象，
  而不是列表。修改字典，则这些视图对象会相应变化



3.文件对象的方法：

* 文件读入：
  * `.read()`：读取接下来的整个文件到单个字符串
  * `.read(n)`：读取接下来的`n`个字节到一个字符串
  * `.readline()`：读取下一行到一个字符串（包括行末的换行符）
  * `.readlines()`：按行读取接下来的整个文件到字符串列表，每个字符串一行  
* 写入文件：
  * `.write(str)`：写入字符串到文件（并不会自动添加换行符以及其他任何字符，`str`是啥就写啥），
     	  返回写入的字符数
  * `.writelines(strlist)`：将字符串列表内所有字符串依次写入文件（并不会自动添加换行符以及其他任何字符）  
* 定位文件：`.seek(N)`方法，将文件偏移修改到字节`N`处以便进行下一次操作
* 文件迭代：文件对象也是一个可迭代对象，每一次迭代返回一行，对于大型文件一次性读取非常耗内存和性能：

* 或者直接使用`pickle`模块自动存储和解析Python对象：
  * 存储：`pickle.dump(obj,file)`，其中`obj`是要存储的Python对象，`file`文件对象
    （用二进制写打开）
  * 加载：`obj=pickle.load(file)`，其中`file`文件对象（用二进制读打开）  
    ![pickle存储解析Python对象](D:/学习/downloadfiles/python_tools-master/python_learning_notes-master/imgs/python_9_6.JPG)

10.`struct`模块能够打包/解包二进制数据

* 打包：`data=struct.pack('>i4sh',7,b'abcd',8)`。其中第一个参数为格式说明字符串，后面的参数为待打包的数据。格式说明字符串为：
  * `>`为说明符
  * `i`说明第一个待打包的数据为整数
  * `4s`说明第二个待打包的数据为4个字节的字节串
  * `h`说明第三个待打包的数据为16进制整数
* 解包：`val=struct.unpack('>i4sh`,data)`。其中第一个参数为格式说明符，第二个参数为已经打包的二进制数据，返回一个元组。  
  ![struct打包/解包二进制数据](D:/学习/downloadfiles/python_tools-master/python_learning_notes-master/imgs/python_9_7.JPG)



.变量名由：下划线或字母开头，后面接任意字母、数字、下划线

* 以单下划线开头的变量名不会被`from module import *`语句导入，如变量名`_x`
* 前后双下划线的变量名是系统预定义的，对解析器有着特殊的意义，如变量名`__x__`
* 仅前面有双下划线的变量名视为类的本地变量，如变量名`__x`

扩展的序列解包赋值：收集右侧值序列中未赋值的项为一个列表，将该列表赋值给带星号`*`的变量

* 左边的变量名序列长度不需要与值序列的长度相等，其中只能有一个变量名带星号`*`
  * 若带星号`*`变量名只匹配一项，则也是产生一个列表，列表中只有一个元素，如`a,*b="12"`，`b`为`[2]`
  * 若带星号`*`变量名没有匹配项，则也是产生空列表，如`a,*b="1"`，`b`为`[]`
* 带星号`*`的变量名可以出现在变量名序列中的任何位置如`*a,b="1234"`，`a`为`[1,2,3]`
* 匹配过程优先考虑不带星号的变量名，剩下的才匹配带星号的变量名
* 以下情况会引发错误：
  * 左侧变量名序列有两个星号，如`*a,*b="abcd"`
  * 左侧变量名序列无星号但是左右长度不匹配，如`a,b="abcd"`
  * 左侧变量名序列星号的名称不在序列中，如`*a='abcd'`



.Python支持`if|else`三元表达式：`Y if X else Z`：  
  当`X`为真时，表达式的值为`Y`；当`X`为假时，表达式的值为`Z`。
  <font color='red'>注意这里为短路计算，并不会同时对`Y`和`Z`求值</font>。

* 三元表达式`X? Y:Z`也能得到同样的效果



* `while`和`else`缩进必须一致。
* `else`可选。`else`子句在控制权离开循环且未碰到`break`语句时执行。即在正常离开循环时执行（`break`是非正常离开循环）
* 在`while`子句中可以使用下列语句：
  * `break`：跳出最近所在的循环到循环外部
  * `continute`：跳过本次循环后续部分，直接掉转到下一轮循环起始处
  * `pass`：占位符，什么都不做



* `for`和`else`缩进必须一致。
* `else`可选。`else`子句在控制权离开循环且未碰到`break`语句时执行。即在正常离开循环时执行（`break`是非正常离开循环）
* 在`for`子句中可以使用`break`、`continute`、`pass`语句
* `target_var`是赋值目标，`iter_obj`是任何可迭代对象。每一轮迭代时将迭代获得的值赋值给`target_var`，然后执行`statement1`