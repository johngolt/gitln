### 数据结构

#### 序列构成的数组

容器序列: `list、tuple`和 `collections.deque `这些序列能存放不同类型的数据。扁平序列: `str、bytes、bytearray、memoryview` 和` array.array`，这类序列只能容纳一种类型。容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。换句话说，扁平序列其实是一段连续的内存空间。由此可见扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型。序列类型还能按照能否被修改来分类。可变序列: `list、bytearray、array.array、collections.deque` 和 `memoryview`。不可变序列: `tuple、str `和 `bytes`。

![](../picture/1/33.png)

列表推导、生成器表达式，以及同它们很相似的集合推导和字典推导，在 `Python3`中都有了自己的局部作用域，就像函数似的。表达式内部的变量和赋值只在局部起作用，表达式的上下文里的同名变量还可以被正常引用，局部变量并不会影响到它们。

###### 数组

如果我们需要一个只包含数字的列表，那么`array.array`比 `list`更高效。数组支持所有跟可变序列有关的操作。另外，数组还提供从文件读取和存入文件的更快的方法，如`.frombytes`和`.tofile`。Python数组跟C语言数组一样精简。创建数组需要一个类型码，这个类型码用来表示在底层的C语言应该存放怎样的数据类型。而且Python不会允许你在数组里存放除指定类型之外的数据。

| 函数               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| `s.fromfile(f, n)` | 将二进制文件f内含有机器值读出来添加到尾部，最多添加 n 项     |
| `s.fromlist(l)`    | 将列表里的元素添加到尾部，如果其中任何一个元素导致了 `TypeError`异常，那么所有的添加都会取消 |
| `s.tobytes()`      | 把所有元素的机器值用 bytes 对象的形式返回                    |
| `s.tofile(f)`      | 把所有元素以机器值的形式写入一个文件                         |
| `s.tolist()`       | 把数组转换成列表，列表里的元素类型是数字对象                 |
| `s.typecode`       | 返回只有一个字符的字符串，代表数组元素在 C 语言中的类型      |

###### 双向队列

`collections.deque`类双向队列是一个线程安全、可以快速从两端添加或者删除元素的数据类型。而且如果想要有一种数据类型来存放最近用到的几个元素，`deque`也是一个很好的选择。这是因为在新建一个双向队列的时候，你可以指定这个队列的大小，如果这个队列满员了，还可以从反向端删除过期的元素，然后在尾端添加新的元素。双向队列实现了大部分列表所拥有的方法，也有一些额外的符合自身设计的方法。但是为了实现这些方法，双向队列也付出了一些代价，从队列中间删除元素的操作会慢一些，因为它只对在头尾的操作进行了优化。`append`和`popleft`都是原子操作，也就说是`deque`可以在多线程程序中安全地当作先进先出的栈使用，而使用者不需要担心资源锁的问题。

| 方法              | 描述                                 |
| ----------------- | ------------------------------------ |
| `s.appendleft(a)` | 添加一个元素到最左侧到第一个元素之前 |
| `s.extendleft(i)` | 将可迭代对象 i 中的元素添加到头部    |
| `s.popleft()`     | 移除第一个元素并返回它的值           |
| `s.rotate(n)`     | 把 n 个元素从队列的一端移到另一端    |

#### 字典和集合

从`UserDict`而不是从`dict`继承的主要原因是，后者有时会在某些方法的实现上走一些捷径，导致我们不得不在它的子类中重写这些方法，但是`UserDict`就不会带来这些问题。`UserDict `并不是 `dict `的子类，但是 `UserDict `有一个叫作 data 的属性，是 `dict `的实例，这个属性实际上是 `UserDict `最终存储数据的地方。

![](../picture/1/35.png)

标准库里的所有映射类型都是利用` dict `来实现的，因此它们有个共同的限制，即只有可散列的数据类型才能用作这些映射里的键。如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现` __hash__() `方法。另外可散列对象还要有`__qe__() `方法，这样才能跟其他键做比较。**如果两个可散列对象是相等的，那么它们的散列值一定是一样的。**一般来讲用户自定义的类型的对象都是可散列的，散列值就是它们的` id() `函数的返回值，所以所有这些对象在比较的时候都是不相等的。如果一个对象实现了 `__eq__ `方法，并且在方法中用到了这个对象的内部状态的话，那么只有当所有这些内部状态都是不可变的情况下，这个对象才是可散列的。`setdefault`用来处理键值缺失情况。

##### 映射的弹性键查询

有时候为了方便起见，就算某个键在映射里不存在，我们也希望在通过这个键读取值的时候能得到一个默认值。有途径能帮我们达到这个目的，一个是通过` defaultdict `这个类型而不是普通的` dict`，另一个是给自己定义一个` dict `的子类，然后在子类中实现`__missing__ `方法。在实例化一个 `defaultdict `的时候，需要给构造方法提供一个可调用对象，这个可调用对象会在 `__getitem__ `碰到找不到的键的时候被调用，让 `__getitem__ `返回某种默认值。`defaultdict `里的` default_factory `只会在 `__getitem__ `里被调用，在其他的方法里完全不会发挥作用。所有的映射类型在处理找不到的键的时候，都会牵扯到` __missing__ `方法。虽然基类 `dict `并没有定义这个方法，但是 `dict `是知道有这么个东西存在的。也就是说，如果有一个类继承了` dict`，然后这个继承类提供了`__missing__ `方法，那么在 `__getitem__ `碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个 `KeyError `异常。`__missing__ `方法只会被 `__getitem__ `调用。提供 `__missing__ `方法对 `get `或者 `__contains__`这些方法的使用没有影响。

##### 集合

![](../picture/1/41.png)

散列表其实是一个稀疏数组：总是有空白元素的数组称为稀疏数组。在一般的数据结构教材中，散列表里的单元通常叫作表元。在` dict `的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。因为 Python 会设法保证大概还有三分之一的表元是空的，所以在快要达到这个阈值的时候，原有的散列表会被复制到一个更大的空间里面。

为了获取` my_dict[search_key] `背后的值，Python 首先会调用` hash(search_key)`来计算` search_key `的散列值，把这个值最低的几位数字当作偏移量，在散列表里查找表元。若找到的表元是空的，则抛出`KeyError `异常。若不是空的，则表元里会有一对` found_key:found_value`。这时候 Python 会检验` search_key == found_key `是否为真，如果它们相等的话，就会返回` found_value`。如果 `search_key `和 `found_key `不匹配的话，这种情况称为散列冲突。发生这种情况是因为，散列表所做的其实是把随机的元素映射到只有几位的数字上，而散列表本身的索引又只依赖于这个数字的一部分。为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊的方法处理一下，把新得到的数字再当作索引来寻找表元。若这次找到的表元是空的，则同样抛出 `KeyError`；若非空，或者键匹配，则返回这个值；或者又发现了散列冲突，则重复以上的步骤。

![](../picture/1/42.png)

#### 文本和字节序列

占位符有多种：  `%s`：字符串； `%r`：也是字符串，但用`repr()`得到的而不是`str()`；  `%c`：字符； `%d`：十进制整数； `%i`：整数； `%e`：浮点指数；  `%f`： 浮点十进制；`%%`：百分号 `%`， `%g`：自动转成浮点`%e`或者`%f`  

转换通用目标结构为：`%[(key_name)][flags][width][.precision]type`

* `key_name`：用于从右边字典中取对应键的值，如：`"%(n)%d %(x)%s" %{"n":3,"x":"apples"}` 
* `flags`：如果为`-`则左对齐；如果为`+`则为正负号；如果为`0`：则补零
* `width`： 指定位宽，至少为`width`字符宽度
* `precision`：指定小数点后几位
* `type`为类型，如`d`,`r`,`f`,`e`等  

格式化字符串除了使用字符串格式化表达式之外，还可以通过字符串的`.format()`方法达到同样的效果。`.format()`方法支持位置参数、关键字参数、以及二者的混合。

* 位置参数： `"{0},{1},{2}".format('abc','def','ghi')`
* 关键字参数：`"{k1},{k2},{k3}".format(k1='abc',k2='def',k3='ghi')`
* 混合使用：`"{0},{1},{k}".format('abc','def',k='ghi')`  

* 格式化字符串中可以指定对象的属性、字典键、序列的索引：指定字典的键：`"{0[a]}".format({'a':'value'})`，指定对象的属性：`"{0.platform}".format(sys)`，也可以用关键字参数：`"{obj.platform}".format(obj=sys)`；指定序列的索引：`"{0[2]}".format("abcd")` ，这里只能进行正索引值，且不能分片 
* 通用目标结构为： `{fieldname!conversionflag:formatspec}`
  * `fieldname`为位置数字 0,1,2,或者为关键字，它后面可选地跟随
  * `conversionflag`为转换标记，没用过，所以不关键。
  * `formatspec`为格式，其结构为：`[[fill] align] [sign] [#] [0] [width] [.precision] [type]`：`fill`一般与`align`为`=`时配合；`align`为对齐：`<`：左对齐；`>`：右对齐；`=`：必须指定`fill`，此时用这个字符填充；`^`：居中对齐；`sign`：为正负号标记；`0`：补0；`width`：位宽；`.precision`：精度；`type`：为类型，如`d`,`r`,`f`,`e`等，但与格式化字符串表达式相比，多了`b`

##### 字符问题

每一个字符对应一个标识或码位，码位时数值，数值与字符一一对应，然后通过编码将数值编码成不同的字节序列，解码就是将字节序列解读成数值，然后通过数值找到对应的字符。不同的编码方式就是不同的函数将字节序列映射成码位。通过一个字典将字符和数字进行一一映射，然后通过字节来表示不同的数字，这样就建立了字节和字符之间的一一对应关系。

字符的最佳定义是Unicode字符。**字符的标识**即码位，是`0~1114111`的数字。字符的具体表述取决于所用的编码。编码是在码位和字节序列之间转换时使用的算法。把码位转换成字节序列的过程是编码；把字节序列转换成码位的过程是解码。把文本转换成字节序列时，如果目标编码中没有定义某个字符，那就会抛出` UnicodeEncodeError `异常，除非把` errors `参数传给编码方法或函数，对错误进行特殊处理。不是每一个字节都包含有效的ASCII字符，也不是每一个字符序列都是有效的` UTF-8 `或`UTF-16`。因此，把二进制序列转换成文本时，如果假设是这两个编码中的一个，遇到无法转换的字节序列时会抛出` UnicodeDecodeError`。另一方面，很多陈旧的 8 位编码如` 'cp1252'` 能解码任何字节序列流而不抛出错误。

有三种字符串相关类型：`str`类型表示`Unicode`文本，为不可变的字符序列，称为字符串；`bytes`表示二进制数据，称为字节串。`bytes`对象其实是小整数的一个序列，每个整数的范围在0～255之间，`list(bytes_obj)`返回一个整数列表而不是字符列表；`bytearray`是一种可变的`bytes`类型，称为可变字节串。`bytearray`是`bytes`的一个变体，它是可变的且支持原地修改。它支持`str`与`bytes`的常见操作，以及与列表相同的一些原地修改操作。字符串的`.encode(encoding)`方法和`bytes(a_string,encoding)`函数将一个字符串实例转换为它原生`bytes`形式；字符串的`str(a_bytes,encoding)`函数和`.decode(encoding)`方法将一个`bytes`实例解码成字符串形式。`bytearray`实例的构造：`bytearray('abc',encoding='ascii')`：通过构造函数传入字符串和编码构造; `bytearray(b'abc')`：通过`bytes`常量构造

##### 处理文本文件

处理文本的最佳实践是“Unicode 三明治”。 意思是，要尽早把输入的字节序列解码成字符串。这种三明治中的“肉片”是程序的业务逻辑，在这里只能处理字符串对象。在其他处理过程中，一定不能编码或解码。对输出来说，则要尽量晚地把字符串编码成字节序列。

![](../picture/1/30.png)

如果打开文件时没有指定 encoding 参数，默认值由`locale.getpreferredencoding()` 提供。如果打开文件时没有指定` encoding `参数，默认值由`locale.getpreferredencoding() `提供。当一个文件以文本模式打开时，读取其数据会自动将其内容解码，并返回一个字符串；当一个文件以文本模式写打开时，写入一个字符串会在将该字符串写入文件之前自动编码它。当一个文件以二进制模式打开时，读取其数据直接返回其原生内容而并不以任何方式解码，也不做任何方式修改，直接作为`bytes`实例返回；写入会接受一个`bytes`实例或者一个`bytearray`实例，并且不加修改地写入到文件

### 把函数视作对象

Python中，函数也是一种对象类型，Python运行到`def`语句时，它将会生成一个新的函数对象，并将该函数对象赋值给这个函数名。函数名成了这个函数对象的引用，`lambda`表达式创建一个函数对象并返回它，但是它并没有绑定一个名字即它是匿名的没有函数名，`return`语句将一个结果对象发送给调用者，`yield`语句使得函数成为一个生成函数，与C语言不同，Python函数在程序运行之前不需要全部定义。`def`在它定义的地方时才评估，而`def`的之内的代码在函数调用的时候才求值，函数主体内的代码直到函数被调用时才运行。函数内的变量名在函数实际执行之前都不会解析。

变量可以在3个不同的地方定义，对应三种不同的作用域：`def`内赋值定义的变量：作用域为本函数，这里的赋值包括显式`=`赋值和隐式赋值。隐式赋值包括，`import`语句隐式赋值，`def`函数定义来隐式赋值，形参匹配来隐式赋值，嵌套的`def`中赋值定义的变量：对于父函数来说，该变量不是本地的，`def`之外赋值，作用域为整个文件全局的 

作用域法则：每个模块文件就是一个全局作用域。从外面看，模块的全局变量就成为该模块对象的属性；从内部看，模块的全局变量就是普通的、作用域为全局的变量，全局作用域的范围仅限于变量所在的单个文件，每次调用函数，都创建一个新的局部作用域，默认情况下，所有函数定义内部的变量都是局部变量，`global`语句声明会将变量名作用域提升至全局，`nonlocal`语句声明会将变量名作用域提升至外层的`def`

变量名查找规则：`LGBE`：首先查找本地作用域`L`，接着查找上一层`def`或`lambda`的本地作用域`E`，接着查找全局作用域`G`，最后查找内置作用域`B`，如果均未找到变量名则报错。 

嵌套作用域中的变量在嵌套的函数调用时才进行查找，而不是定义时。 

```python
def func():
	acts=[]
	for i in range(5):
		acts.append(lambda x:i**x) #添加匿名函数对象
	return acts
acts=func();acts[0](2) #调用时才开始查找i,此时i最后被记住的值是4
```

参数传递的性质：参数的传递是通过自动将对象赋值给本地变量名来实现的，在函数内部的参数名赋值不会影响到实参对象，只是将变量名重新引用到另一个对象，若实参对象为可变对象，则在函数内原地修改参数对象会影响所有的指向该实参对象的引用

默认情况下，参数匹配是通过其位置进行匹配的，从左到右一一匹配。必须精确传递和函数签名中参数名一样多的实参。关键字参数：允许通过变量名进行匹配，而不是通过位置。其中关键字顺序可以任意；默认参数：函数定义时，可以为参数设定默认值，这样允许调用时传递较少的参数，默认实参后面不能跟随非默认实参。如果出现这种情况则报语法错误；可变参数：函数能用特定的参数（以`*`开头），收集任意多的额外位置参数，将收集到的位置相关的参数到一个新元组中。  函数能用特定的参数（以`**`开头），收集任意多的额外关键字参数，将收集关键字相关的参数到一个新字典中；`keyword-only`参数：它是一种命名参数，出现在`*`参数之后，在`**`参数之前。所有的`keyword-only`参数必须使用关键字语法传递。   

可变参数解包：调用者可以用`*`语法将实参（如元组、列表、`set`）打散，形成位置参数，调用者可以用`**`语法将字典实参打散，形成关键字参数    

9.函数定义时的参数类型顺序：

```python
def func(a,b,c='c',*d,e,f='f',**g):
	pass
	func('a','b',e='e',*seq,**dic)
#seq是一个序列，它解包之后优先覆盖c，剩下的再收集成元组传给d
#dic是一个字典，它解包之后优先考虑e,f，剩下的在收集成字典传递给g
#e='e'这个关键字实参也可以位于'b'之后的任何位置
#关键字实参必须位于位置实参之后 
```

#### 一等函数

在Python中，函数是一等对象。编程语言理论家把**一等对象**定义为满足下述条件的程序实体：在运行时创建；能赋值给变量或数据结构中的元素；能作为参数传给函数；能作为函数的返回结果

除了用户定义的函数，调用运算符，即`()`，还可以应用到其他对象上。如果想判断对象能否调用，可以使用内置的 callable() 函数。**用户定义的函数**：使用 def 语句或 lambda 表达式创建；**内置函数**：使用 C 语言实现的函数，如` len `或 `time.strftime`；**内置方法**：使用 C 语言实现的方法，如`dict.get`；**方法**：在类的定义体中定义的函数；**类**：调用类时会运行类的` __new__ `方法创建一个实例，然后运行` __init__ `方法，初始化实例，最后把实例返回给调用方。因为 Python 没有`new`运算符，所以调用类相当于调用函数；**类的实例**：如果类定义了` __call__ `方法，那么它的实例可以作为函数调用；**生成器函数**：使用 yield 关键字的函数或方法。调用生成器函数返回的是生成器对象。

##### 函数内省

函数专有而用户定义的一般对象没有的属性。

| 名称             | 类型             | 说明                                 |
| ---------------- | ---------------- | ------------------------------------ |
| `__annotation__` | `dict`           | 参数和返回值的注解                   |
| `__call__`       | `method-wrapper` | 实现`()`运算符；即可调用对象协议     |
| `__closure__`    | `tuple`          | 函数闭包，即自由变量的绑定           |
| `__code__`       | `code`           | 编译成字节码的函数元数据和函数定义体 |
| `__defaults__`   | `tuple`          | 形式参数的默认值                     |
| `__get__`        | `method-wrapper` | 实现只读描述符协议                   |
| `__globals__`    | `dict`           | 函数所在模块中的全局变量             |
| `__kwdefaults__` | `dict`           | 仅限关键字形式参数的默认值           |
| `__name__`       | `str`            | 函数名称                             |
| `__qualname__`   | `str`            | 函数的限定名称                       |

定义函数时若想指定仅限关键字参数，要把它们放到前面有`*`的参数后面。如果不想支持数量不定的定位参数，但是想支持仅限关键字参数，在签名中放一个`*`，如`def f(a, *, b)`。函数对象有个`__defaults__ `属性，它的值是一个元组，里面保存着定位参数和关键字参数的默认值。仅限关键字参数的默认值在`__kwdefaults__`属性中。然而，参数的名称` __code__`属性中，它的值是一个`code`对象引用，自身也有很多属性。

#### 函数装饰器和闭包

装饰器是用于包装其他可调用对象的一个可调用对象，它是一个可调用对象，其调用参数为另一个可调用对象，它返回一个可调用对象：一个函数对象是可调用对象。一个类对象是可调用对象，对它调用的结果就是返回类的实例。实现了`.__call__()`方法的类，其实例对象是可调用对象，对它调用的结果就是调用`.__call__()`方法。装饰器有两种使用形式：函数的装饰器：在函数对象定义的时候使用装饰器，用于管理该函数对象；类的装饰器：在类定义的时候使用该装饰器，用于管理该类以及类的实例

函数的装饰器：用于管理函数。函数的装饰器声明为：

```python
@decorator
def func(*pargs,**kwargs):
	pass
func=decorator(func) # 等价于
```

执行了装饰器的`def`之后，函数名指向的不再是原来的函数对象，而是：一个可调用对象， 当`decorator`是个函数时由`decorator(func)`函数返回的；`decorator`类的实例，当`decorator`是个类时，由`decorator(func)`构造方法返回

类的装饰器：用于管理类。类的装饰器声明为：

```python
@decorator
class A:
	pass
A=decorator(A)
```

类的装饰器并不是拦截创建实例的函数调用，而是返回一个不同的可调用对象，执行了装饰器的`class`之后，类名指向的不再是原来的类对象，而是：一个可调用对象， 当`decorator`是个函数时由`decorator(func)`函数返回的；`decorator`类的实例，当`decorator`是个类时，由`decorator(func)`构造方法返回

```python
def decorator(func): #定义了一个叫decorator的装饰器
	#某些处理
	return func #返回可调用对象
class decorator: #也可以用类来实现装饰器
	def __init__(self,func):
		self.func=func
	def __call__(self,*args,**kwargs):
		return self.func
def decorator(func): #定义了一个叫decorator的装饰器
	def wrapper(*args):
		#使用func或其他的一些工作
	return wrapper #返回可调用对象
```

装饰器的嵌套：

```python
@decoratorA
@decoratorB
@decoratorC
def func():
	pass
f=A(B(C(f)))
```

装饰器可以携带参数。函数定义的装饰器带参数：它其实是一个嵌套函数。外层函数的参数为装饰器参数，返回一个函数。内层函数的参数为`func`，返回一个可调用参数，<font color='red'>内层函数才是真正的装饰器</font>

```
def decorator(*args,**kwargs): 
	print("this is decorator1:",args,kwargs)
	def actualDecorator(func): # 这才是真实的装饰器
		...
		return func
	return actualDecorator
```

类定义的装饰器带参数：它其实是一个嵌套类。外层类的初始化函数的参数为装饰器参数，外层类的`__call__`函数的参数为`func`，返回值为一个类的实例；内层类的初始化函数参数为`func`；内层类的`__call__`函数使用`func`，<font color='red'>内层类才是真正的装饰器</font>

```python
class decorator2:
	class ActualDecorator: #这才是真实的装饰器
		def __init__(self,func):
			...
			self.func=func#记住func
		def __call__(self,*args,**kwargs):
			...
			return self.func(*args,**kwargs) #使用func
	def __init__(self,*args,**kwargs):
		...
	def __call__(self,func):
		...
		return decorator2.ActualDecorator(func) 
```

总结：不带参数的装饰器`decorator`装饰一个名字`F`（可能为函数名、也可能为类名）`@decorator`：则执行的是：`F=decorator(F)`，直接使用`F`；带参数的装饰器`decorator`装饰一个名字`F`（可能为函数名、也可能为类名）`@decorator(args)`：则执行的是：`F=decorator(args)(F)`，间接使用`F` 

装饰器的一大特性是，能把被装饰的函数替换成其他函数。第二个特性是，装饰器在加载模块时立即执行：它们在被装饰的函数定义之后立即运行。这通常是在导入时，函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。

![](../picture/1/31.png)

闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。`nonlocal `声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为` nonlocal `声明的变量赋予新值，闭包中保存的绑定会更新。解析源码中的装饰器时，`Python`把被装饰的函数作为第一个参数传给装饰器函数。那怎么让装饰器接受其他参数呢？答案是：创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。

### 面向对象惯用法

Python中，类`class`与实例`instance`是两种不同的对象类型：类对象是实例对象的工厂；类对象与实例对象都有各自独立的命名空间；实例对象可自动存取类对象中的变量名；类属性为所有的实例对象提供状态和行为，它是由该类创建的所有实例对象共享的，每个实例对象都有自己的命名空间。同一个类的实例对象不一定属性都相同，每一个实例对象继承类的属性并创建了自己的命名空间，类创建的实例对象是有新的命名空间。刚开始该命名空间是空的，但它会继承创建该实例所属类对象的属性。继承的意思是，虽然实例对象的命名空间是空的。但是名字查找会自动上升到类对象的名字空间去查找，可以在`class`语句外创建类对象的新属性，通过向类对象直接赋值来实现。

类可以继承。被继承的类称为超类，继承类称为子类。类对象会继承其超类对象中定义的所有类属性名称，类对象的 `.__dict__`属性是类对象的命名空间，是一个类字典对象`mappingproxy`对象 ； 实例对象的 `.__dict__`属性是实例对象的命名空间，是一个字典； 实例对象的`.__class__`属性是它所属的类，类对象的`__bases__`属性是它超类对象的元组，类对象的`__name__`属性是类名，在子类中调用超类的方`superClass.func(obj,args)`，其中`obj`通常为`self` 

若子类重新定义了超类的变量名，子类会取代并定制所继承的行为。这称为重载。在Python中，当对象通过点号运算读取属性值时就会发生继承，而且涉及了搜索属性定义树。每次使用`name.attr`时(`name`为实例对象或者类对象），Python会从底部向上搜索命名空间树。先从本对象的命名空间开始，一直搜索到第一个找到的`attr`名字就停止，命名空间树中较低位置处的定义会覆盖较高位置处的定义，继承树的搜索仅仅发生在读取属性值的时候。在写属性值时，执行的是属性的定义（当前命名空间中该名字不存在）或赋值（当前命名空间中该名字已存在）语义。

~~~mermaid
graph BT;
A(实例命名空间)-->B[类命名空间];
B-->C[超类1命名空间];
B-->D[超类2命名空间];
style A fill:#f9f,stroke:#333;
~~~

在Python3中所有的类都是新式类。所有的类都是从`object`内置类派生而来，`type(obj)`返回对象实例所属的类对象，`type(classname)`返回`"type"`，因为所有`class`对象都是`type`的实例，由于所有`class`均直接或者间接地派生自`object`类，因此每个实例对象都是`object`类的实例，`object`是`type`类的实例，但是同时`type`又派生自`object`。Python3中的类有一个`.__slots__`属性，它是一个字符串列表。这个列表限定了类的实例对象的合法属性名。如果给实例赋了一个`.__slots__`列表之外的属性名会引发异常，当有`.__slots__`列表存在时，默认会删除`.__dict__`属性，而`getattr()`，`setattr()`以及`dir()`等函数均使用`.__slots__`属性，因此仍旧可以正常工作，在继承中: 若子类继承自一个没有`.__slots__`的超类，则超类的`.__dict__`属性可用，则子类中的`.__slots__`没有意义。因为子类继承了超类的`.__dict__`属性，若子类有`.__slots__`，超类也有`.__slots__`，子类的合法属性名为父类和子类的`.__slots__`列表的并集，若超类有`.__slots__`，子类未定义`.__slots__`，则子类将会有一个`.__dict__`属性

```python
  class A:
    	def __init__(self):
        	self._x = None
    	@property #定义了一个property get函数，必选
    	def x(self): # property name 就是 get函数的函数名
        	"""I'm the 'x' property."""
        	return self._x
    	@x.setter #定义了一个property set函数，可选
    	def x(self, value):
        	self._x = value
    	@x.deleter #定义了一个property del函数，可选
    	def x(self):
        	del self._x
```

Python类中有两种特殊的方法：`staticmethod`方法和`classmethod`方法

* `staticmethod`方法：当以实例对象调用`staticmethod`方法时，Python并不会将实例对象传入作为参数；而普通的实例方法，通过实例对象调用时，Python将实例对象作为第一个参数传入	
* `classmethod`方法：当以实例对象或者类对象调用`classmethod`方法时，Python将类对象（如果是实例对象调用，则提取该实例所属的类对象）传入函数的第一个参数`cls`中		

总结一下，类中可以定义四种方法：普通方法：方法就是类对象的一个属性，执行常规函数调用语义`classname.method(args)`；实例方法：传入一个实例作为方法的第一个实参。调用时可以：`obj.method(args)`:通过实例调用、`classname.method(obj,args)`：通过类调用；`staticmethod`方法：* `obj.method(args)`通过实例调用时，执行的是`classname.method(args)`语义；`classmethod`方法：* `obj.method(args)`执行的是`classname.method(classname,args)`语义

类的实例方法中，用哪个实例调用的该方法，`self`就是指向那个实例对象，类的`classmethod`方法中，用哪个类调用该方法，`cls`就指向那个类对象。类对象与实例对象都是可变对象，可以给类属性、实例属性进行赋值，这就是原地修改。这种行为会影响对它的多处引用。若类的某个属性是可变对象，则对它的修改会立即影响所有的实例对象。多重继承中，超类在`class`语句首行内的顺序很重要。Python搜索继承树时总是根据超类的顺序，从左到右搜索超类。类对象的`.__mro__`属性。它是一个`tuple`，里面存放的是类的实例方法名解析时需要查找的类。Python根据该元组中类的前后顺序进行查找。类对象的`.__mro__`列出了`getattr()`函数以及`super()`函数对实例方法名字解析时的类查找顺序。

`super()`函数：`super()`返回一个`super`实例对象，它用于代理实例方法/类方法的执行：`super(class,an_object)`：要求`isinstance(an_object,class)`为真。代理执行了实例方法调用；`super(class,class2)`：要求 `issubclass(class2,class)`为真。代理执行了类方法调用

有两种特殊用法：`super(class)`：返回一个非绑定的`super`对象，在类的实例方法中，直接调用`super()`，等价于`super(classname,self)`，这里`self`可能是`classname`子类实例，在类的类方法中，直接调用`super()`，等价于`super(classname,cls)`（这里`cls`可能是`classname`子类）

原理：`super`的原理类似于：

``` 
def super(cls,instance):
	mro=instance.__class__.__mro__ #通过 instance生成 mro
	return mro[mro.index(cls)+1] #查找cls在当前mro中的index,返回cls的下一个元素
```

```
class Root:
	def method1(self):
		print("this is Root")
class B(Root):
	def method1(self):
		print("enter B")
		print(self)
		super(B,self).method1() #也可以简写为 super().method1()
		print("leave B")
class C(Root):
	def method1(self):
		print("enter C")
		print(self)
		super().method1() #也可以写成super(C,self).method1()
		print("leave C")
class D(B,C):
	pass
```

* 调用`D().method1()`--> `D`中没有`method1` 
* `B`中找到（查找规则：`D.__mro__`)  --> 执行`B`中的`method1`。此时`self`为D实例。`D.__mro__`中，`B`的下一个是`C`，因此`super(B,self）.method1()`从类`C`中查找`method1`。
* 执行`C`的`method1`。此时`self`为D实例。`D.__mro__`中，`C`的下一个是`Root`，因此`super(C,self）.method1()`从类`Root`中查找`method1`。
* 执行`Root`的`method1`。
* `print(self)`可以看到，这里的`self`全部为 `D`的实例

##### 元类

所有用户定义的类都是`type`类对象的实例，`type`类是应用最广的元类。`class`语句的内部机制：在一条`class`语句的末尾，Python会调用`type`类的构造函数来创建一个`class`对象。

```python
MyClass=type(classname,superclasses,attributedict) #新建了一个类，类名叫MyClass
# classname:类名，会成为MyClass类的 .__name__属性
# superclasses:类的超类元组，会成为MyClass类的 .__bases__属性
# attributedict:类的命名空间字典，会成为MyClass类的 .__dict__ 属性
```

`type`类定义了一个`.__call__(...)`方法。该方法运行`type`类定义的两个其他方法：

* `.__new__(mclass,classname,superclasses,attributedict)`方法，它返回新建的`MyClass`类，`mclass`：为本元类，这里是`type`类，`classname`：为被创建的类的类名，这里是`'MyClass'`，`superclasses`：为被创建的类的超类元组，`attributedict`：为被创建的类的名字空间字典  
* `.__init__(customclass,classname,superclasses,attributedict)`方法，它初始化新建的`MyClass`类，`customclass`：为被创建的类，这里是`MyClass`类，`classname`：为被创建的类的类名，这里是`'MyClass'`，`superclasses`：为被创建的类的超类元组，`attributedict`：为被创建的类的名字空间字典  

所有的类型均由`type`类创建。要通知Python用一个定制的元类来创建类，可以直接声明一个元类来拦截常规的类创建过程。所有元类必须是`type`的子类

```python
class MetaClass(type):
	def __new__(mclass,classname,superclasses,attributedict):		
		return type.__new__(mclass,classname,superclasses,attributedict)
	def __init__(customclass,classname,superclasses,attributedict):
		return type.__init__(customclass,classname,superclasses,attributedict)
class MyClass(metaclass=MetaClass):
	pass
```

继承的超类也列在括号中，但是要在元类之前，也用逗号分隔：`class MyClass(BaseCls1,BaseCls2,metaclass=MetaClass)`

使用元类声明后，在`class`语句底部进行创建`MyClass`类时，改为调用元类`MetaClass`而不是默认的`type`：`MyClass=Meta('MyClass',superclasses,attributedict)`

* 元类`MetaClass`要实现元类协议：重载元类的`.__new__(Meta,classname,superclasses,attributedict)`方法，它返回新建的`MyClass`类；重载元类的`.__init__(customclass,classname,superclasses,attributedict)`方法，
  它初始化新建的`MyClass`类，`type`类的`.__call__(...)`方法将创建和初始化`MyClass`类对象的调用委托给元类``MetaClass`

事实上元类只用于创建类对象，元类并不产生元类自己的实例。因此元类的名字查找规则有些不同：`.__call__`，`.__new__`，`.__init__`方法均在类中查找；元类的继承：元类声明由子类继承，即子类的构建也是由父类的元类负责，如果元类是以函数的方式声明，则子类的构建不再继承这个函数式元类；元类中的属性并不进入自定义类的命名空间，即元类中声明的一些类属性与被创建类的名字空间无关，自定义的类，如果没有显示指定元类，也没有指定父类，则默认使用`type`作为元类

##### 面向对象编程

在面向对象的编程中，模块化和层次化组织的机制是一种称为继承的技术。这个技术允许基于一个现有的类作为起点定义新的类。在面向对象的术语中，通常描述现有的类为基类、父类或者超类，而称新定义的类为子类。有两种方式可以让子类有别于父类。子类可以通过提供一个新的覆盖现有方法的实现方法特化一个现有的行为。子类也可以通过提供一些权限的方法扩展其父类。如一个类的唯一目的是作为继承的基类，那么这个类就是一个抽象基类。更正式地说，一个抽象类不能直接实例化，而具体的类可以被实例化。

当在python中以`x+y`计算两个数的和时，x和y这两个名称一定要与先前作为值的对象相关联；如果没有找到相关定义，会抛出一个`NameError`异常。确定与标识符相关联的值的过程称为名称解析。每当标识符分配一个值，这个定义都有特定的范围。最高级赋值通常时全局范围，对于在函数体内的赋值，其范围通常时该函数调用的局部。python中每一个定义域使用了一个抽象名称，称为命名空间。命名空间管理当前在给定作用域内定义的所有标识符。python中实现命名空间使用自己的字典将每一个标识符字符串映射到其相关的值。python提供几种方法来检查一个给定的命名空间。函数`dir`报告给定命名空间中的标识符的名称，而函数`vars`返回完整的字典。默认情况下，调用`dir`和`vars`报告的是执行过程中本地封闭的命名空间。在命名中指示标识符时，python会在名称解析过程中搜索一系列的命名空间。首先，搜索的是所给名字的本地命名空间，若没有找到，则搜索外一层的命名空间，然后以此类推。

实例方法：定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法；

类方法：定义：使用装饰器`@classmethod`。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法；

静态方法：定义：使用装饰器`staticmethod`。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；静态方法是类中的函数，不需要实例。静态方法主要是用来存放逻辑性的代码，逻辑上属于类，但是和类本身没有关系，也就是说在静态方法中，不会涉及到类中的属性和方法的操作。可以理解为，静态方法是个独立的、单纯的函数，它仅仅托管于某个类的名称空间中，便于使用和维护。

封装：将内部实现包裹起来，对外透明，提供`api`接口进行调用的机制。将数据与具体操作的实现代码放在某个对象内部，外部无法访问。必须要先调用类的方法才能启动。
继承：即一个派生类继承父类的变量和方法。
多态：根据对象类型的不同以不同的方式进行处理。

###### 魔法方法

| 魔法方法                         | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `__init()__`                     | 实例化方法，通过类创建实例时，自动触发执行。                 |
| `__module__`                     | 前者表示当前操作对象在属于那个模块；                         |
| `__slots__`                      | python作为一种动态语言，可以在类定义完成和实例化后给类或者对象继续添加随意个数或者任意类型的变量或方法，可以使用`slots`限制实例的变量。`slots`定义的属性仅对当前类的实例起作用，对继承它的子类是不起作用的。 |
| `__dict__`                       | A dictionary or other mapping object used to store an object's attributes. |
| `__mro__`                        | 显示指定类的所有继承脉络和继承顺序，假如这个指定的类不具有某些方法和属性，但与其有血统关系的类中具有这些属性和方法，则在访问这个类本身不具有的这些方法和属性时，会按照`__mro__`显示出来的顺序一层一层向后查找，直到找到为止。 |
| `__getattribute__`               | 属性访问拦截器，在访问实例属性时自动调用。在python中，类的属性和方法都理解为属性，且均可以通过`__getattribute__`获取。当获取属性时，相当于对属性进行重写，直接`return object.__getattribute__(self, *args, **kwargs)`或者根据判断`return`所需要的重写值，如果需要获取某个方法的返回值时，则需要在函数后面加上一个()即可。如果不加的话，返回的是函数引用地址。 |
| `__class__`                      | 获得已知对象的类                                             |
| `__call__(self[, args...])`      | 允许一个类的实例像函数一样被调用：`x(a, b) `调用` x.__call__(a, b)` |
| `__getattr__(self, name)`        | 定义当用户试图获取一个不存在的属性时的行为                   |
| `__setattr__(self, name, value)` | 定义当一个属性被设置时的行为                                 |
| `__get__(self, instance, owner)` | 定义当描述符的值被取得时的行为                               |
| `__set__(self, instance, value)` | 定义当描述符的值被改变时的行为                               |
| `__delete__(self, instance)`     | 定义当描述符的值被删除时的行为                               |
| `__getitem__(self, key)`         | 定义获取容器中指定元素的行为，相当于` self[key]`             |
| `__setitem__(self, key, value)`  | 定义设置容器中指定元素的行为，相当于 `self[key] = value`     |
| `__delitem__(self, key)`         | 定义删除容器中指定元素的行为，相当于` del self[key]`         |
| `__contains__(self, item)`       | 定义当使用成员测试运算符`in` 或` not in`时的行为             |
| `__reversed__(self)`             | 定义当被 `reversed() `调用时的行为                           |
| `__bases__`                      | 获取指定类的所有父类构成元素，使用方法为类名`.__bases__`·    |
| `__hash__(self)`                 | 定义当被` hash() `调用时的行为                               |

##### 对象引用、可变性和垃圾回收

每个标识符与其所引用的对象的内存地址隐式相关联。python是一种动态语言类型，标识符的数据类型并不需要事先声明。标识符可以与任何类型的对象相关联，并且它可以在以后重新分配给相同或不同类型的另一个对象。虽然标识符没有被声明为确切的类型，但它所引用的对象有一个明确的类型。

当标识符a和b是同一个对象的别名时，表达式`a is b`的结果为真，表达式`a==b`是一个更一般的等价概念。如果标识符a和b指向同一个对象，那么表达式`a==b`为真。如果标识符指向不同的对象，但这些对象的值被认为是等价的，那么`a==b`的结果也为真。精确的等价概念取决于数据类型。

python中的赋值语句不会创建对象的副本，而只是给对象绑定了新的名称。浅拷贝会创建一个新的集合对象，然后用原对象的引用来填充它。实质上，浅拷贝只有一层。拷贝过程不会递归，因此不会创建子对象本身的副本。深拷贝会递归拷贝过程。这意味着会首先构造一个新的集合对象，然后递归地填充原始对象中的子对象的副本。以这种方式拷贝对象会遍历整个对象树，从而创建原始对象及其所有子对象的完全独立的副本。

所有python对象拥有三个属性：身份、类型、值。可变对象值值可变，身份不可变；不可变对象指身份和值都不可变。每个对象都会在内存中申请一块空间来保存该对象，该对象在内存中所在位置的地址被称为引用。在开发程序时，所定义的变量名实际就是对象的地址引用。赋值的本质就是让多个变量同时引用同一个对象的地址。引用实际就是内存中的一个数字地址编号，在使用对象时，只要知道这个对象的地址，就可以操作这个对象，但是因为这个数字地址不方便在开发时使用和记忆，所以使用变量名的形式来代替对象的数字地址。 在 Python 中，变量就是地址的一种表示形式，并不开辟开辟存储空间。

可变对象和不可变对象在拷贝时情况是不一样的：不可变对象的拷贝只在修改的时候才会在内存中开辟新的空间，而拷贝实际上是让多个对象同时指向同一个引用，和对象赋值没有区别。可变对象在浅拷贝时只拷贝第一层中的引用，深拷贝时，会逐层拷贝，直到所有的引用都是不可变对象位置。

![](../picture/1/32.png)

理解 Python 中的赋值语句，应该始终先读右边。对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。因为变量只不过是标注，所以无法阻止为对象贴上多个标注。贴的多个标注，就是别名。每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理解为对象在内存中的地址。is 运算符比较两个对象的标识；id() 函数返回对象标识的整数表示。Python 唯一支持的参数传递模式是共享传参。共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识

##### `del`和垃圾回收

`del `语句删除名称，而不是对象。`del `命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。 重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。在 `CPython `中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少引用指向自己。当引用计数归零时，对象立即就被销。`CPython 2.0 `增加了分代垃圾回收算法，用于检测引用循环中涉及的对象组——如果一组对象之间全是相互引用，即使再出色的引用方式也会导致组中的对象不可获取。正是因为有引用，对象才会在内存中存在。当对象的引用数量归零后，垃圾回收程序会把对象销毁。但是，有时需要引用对象，而不让对象存在的时间超过所需时间。这经常用在缓存中。弱引用不会增加对象的引用数量。引用的目标对象称为所指对象。因此我们说，弱引用不会妨碍所指对象被当作垃圾回收。弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用着而始终保存缓存对象。

#### 序列的修改、散列和切片

Python 的序列协议只需要 `__len__ `和 `__getitem__ `两个方法。任何类，只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。

调用`dir(slice)`得到的结果中有个`indices`属性，`S.indices(len) -> (start, stop, stride)`给定长度为` len`的序列，计算 S 表示的扩展切片的起始和结尾索引，以及步幅。超出边界的索引会被截掉，这与常规切片的处理方式一样。换句话说，`indices` 方法开放了内置序列实现的棘手逻辑，用于优雅地处理缺失索引和负数索引，以及长度超过目标序列的切片。这个方法会“整顿”元组，把` start、stop` 和`stride` 都变成非负数，而且都落在指定长度序列的边界内。

`my_seq[a:b:c]` 句法背后的工作原理：创建 `slice(a, b, c)`对象，交给` __getitem__ `方法处理。`a:b:c `这种用法只能作为索引或者下标用在` [] `中来返回一个切片对象：`slice(a, b,c)`。对 `seq[start:stop:step] `进行求值的时候，Python 会调用`seq.__getitem__(slice(start, stop, step))`。要正确处理这种` [] `运算符的话，对象的特殊方法 `__getitem__ `和 `__setitem__ `需要以元组的形式来接收`a[i, j] `中的索引。也就是说，如果要得到 `a[i, j] `的值，Python 会调用`a.__getitem__((i, j))`。

#### 从协议到抽象基类

鸭子类型：对象的类型无关紧要，只要实现了特定的协议即可。猴子补丁：在运行时修改类或模块，而不改动源码。猴子补丁很强大，但是打补丁的代码与要打补丁的程序耦合十分紧密，而且往往要处理隐藏和没有文档的部分。白鹅类型指，只要`cls`是抽象基类，即`cls`的元类是`abc.ABCMeta`，就可以使用`isinstance(obj, cls)`。

导入时，Python 不会检查抽象方法的实现，在运行时实例化时才会真正检查。因此，如果没有正确实现某个抽象方法，Python 会抛出`TypeError`异常。

![](../picture/1/34.png)

`Iterable、Container `和 `Sized`:各个集合应该继承这三个抽象基类，或者至少实现兼容的协议。`Iterable `通过
`__iter__ `方法支持迭代，`Container`通过 `__contains__ `方法支持`in `运算符，`Sized`通过 `__len__ `方法支持 `len() `函数。`Sequence、Mapping `和 `Set`这三个是主要的不可变集合类型，而且各自都有可变的子类。`Callable `和 `Hashable`这两个抽象基类与集合没有太大的关系，只不过因为` collections.abc `是标准库中定义抽象基类的第一个模块，而它们又太重要了，因此才把它们放到`collections.abc`模块中。我从未见过`Callable`或`Hashable`的子类。这两个抽象基类的主要作用是为内置函数`isinstance`提供支持，以一种安全的方式判断对象能不能调用或散列。

#### 继承

任何实现多重继承的语言都要处理潜在的命名冲突，这种冲突由不相关的祖先类实现同名方法引起。这种冲突称为“菱形问题”。

![](../picture/1/36.png)

##### 运算符重载

Python中所有可以被重载的方法名称前、后均有两个下划线字符，以便将它与其他类内定义的名字区分开来，如`__add__`；若使用未定义运算符重载方法，则它可能继承自超类。若超类中也没有则说明你的类不支持该运算，强势使用该运算符则抛出异常  

`.__init__(self,args)`方法：称为构造函数。当新的实例对象构造时，会调用`.__init__(self,args)`方法。它用于初始化实例的状态  

`.__getitem__(self,index)`和`.__setitem(self,index,value)__`方法：对于实例对象的索引运算，会自动调用`.__getitem__(self,index)`方法，将实例对象作为第一个参数传递，方括号内的索引值传递给第二个参数;对于分片表达式也调用`.__getitem__(self,index)`方法。实际上分片边界如`[2:4]`绑定到了一个`slice`分片对象上，该对象传递给了`.__getitem__`方法。  对于带有一个`.__getitem__`方法的类，该方法必须既能针对基本索引（一个整数），又能针对分片调用（一个`slice`对象作为参数；`.__getitem__(self,index)`也是Python的重载迭代方式之一。一旦定义了这个方法，`for`循环每一次循环时可以调用`.__getitem__(self,index)`方法。因此任何响应了索引运算的内置或者用户自定义的实例对象通用可以响应迭代。

`.__setitem(self,index,value)__`方法类似地拦截索引赋值和分片赋值。第一个参数为实例对象，第二个参数为基本索引或者分片对象，第三个参数为值  

`.__index__(self)`方法：该方法将实例对象转换为整数值。即当要求整数值的地方出现了实例对象时自行调用。  

`.__getattr__(self,'name')`方法：拦截属性点号运算`obj.name`。只有当对未定义的属性名称进行点号运算时，实例对象会调用此方法，当Python可以从继承树中找到该属性名时，并不会调用`.__getattr__(self,'name')`方法，属性不仅仅是变量名，也可以是方法名，内置的`getattr(obj,'name')`函数等价于调用`obj.name`，它执行继承搜索。搜不到时调用`.__getattr__(self,“name”)`方法，如果没有定义`.__getattr__(self,“name”)`方法，则对于不知道如何处理的属性，则Python抛出内置的`AttributeError`异常  

`.__setattr__(self,'name',value)`方法：拦截所有的属性赋值语句对于属性赋值语句，因为如果该属性曾经不存在，则一旦赋值就增加了一个新的属性，属性不仅仅是变量名，也可以是方法名，注意：`.__setattr__(self,'name',value)`方法的函数体内，任何对`self`属性赋值语句(`self.name=value`)都会再次递归调用`.__setattr__(self,'name',value)`函数，为了防止`.__setattr__(self,'name',value)`函数体内的无穷递归，在该方法内的`self`属性赋值要采用属性字典索引的方法：`self.__dict__['name']=value`，内置的`setattr(obj,'name',value)`函数等价于调用`obj.name=value`

`.__getattribute__(self,'name')`方法：拦截所有的属性读取，而不仅仅是那些未定义的。注意：`.__getattribute__(self,'name')`方法的函数体内，任何对`self`属性读取语句(`self.name`)都会再次递归调用`.__getattribute__(self,'name')`函数。尽量不要重载`.__getattribute__(self,'name')`方法避免无穷递归

通过`.__getattr__`与`.__setattr__`方法混合使用可以模拟实例对象的私有属性：实例对象保存一个`self.private`变量名列表，对`.__setattr__`与`.__getattr__`，判断属性名是否在`self.private`变量名列表中。若是，则抛出异常

`.__call__(self,*pargs,**kwargs)`方法：函数调用方法。当调用实例对象时，由`.__call__(self,*pargs,**kwargs)`方法拦截。`.__call__(self,*pargs,**kwargs)`方法支持所有的参数传递方式 

运算符重载的作用是让用户定义的对象使用中缀运算符如`+`和`|`或一元运算符如`-`和`~`。说得宽泛一些，在 Python 中，函数调用`()`、属性访问`.`和元素访问 / 切片`[]`也是运算符。不能重载内置类型的运算符；不能新建运算符，只能重载现有的；某些运算符不能重载`is、and、or`和`not`

| 类别               | 方法名和对应的运算符                                         |
| ------------------ | ------------------------------------------------------------ |
| 一元运算符         | `__neg__ -、__pos__ +、__abs__ abs()`                        |
| 众多比较运算符     | `__lt__ <、__le__ <=、__eq__ ==、__ne__ !=、__gt__ >、__ge__ >=` |
| 算术运算符         | `__add__ +、__sub__ -、__mul__ *、__truediv__ /、__floordiv__ //、__mod__ %、__divmod__<br/>divmod()、__pow__ ** 或pow()、__round__ round()` |
| 反向算术运算符     | `__radd__、__rsub__、__rmul__、__rtruediv__、__rfloordiv__、__rmod__、__rdivmod__、__rpow__` |
| 增量赋值算术运算符 | `__iadd__、__isub__、__imul__、__itruediv__、__ifloordiv__、__imod__、__ipow__` |
| 位运算符           | `__invert__ ~、__lshift__ <<、__rshift__ >>、__and__ &、__or__` |
| 反向位运算符       | `__rlshift__、__rrshift__、__rand__、__rxor__、__ror__`      |
| 增量赋值位运算符   | `__ilshift__、__irshift__、__iand__、__ixor__、__ior__`      |

跟运算符无关的特殊方法

| 类别                    | 方法名                                                       |
| ----------------------- | ------------------------------------------------------------ |
| 字符串/字节序列表示形式 | `__repr__、__str__、__format__、__bytes__`                   |
| 数值转换                | `__abs__、__bool__、__complex__、__int__、__float__、__hash__、__index__` |
| 集合模拟                | `__len__、__getitem__、__setitem__、__delitem__、__contains__` |
| 迭代枚举                | `__iter__、__reversed__、__next__`                           |
| 可调用模拟              | `__call__`                                                   |
| 上下文管理              | `__enter__、__exit__`                                        |
| 实例创建和销毁          | `__new__、__init__、__del__`                                 |
| 属性管理                | `__getattr__、__getattribute__、__setattr__、__delattr__、__dir__` |
| 属性描述符              | `__get__、__set__、__delete__`                               |
| 跟类相关的服务          | `__prepare__、__instancecheck__、__subclasscheck__`          |

Python 为中缀运算符特殊方法提供了特殊的分派机制。对表达式`a + b`来说，解释器会执行以下几步操作。(1) 如果`a`有`__add__`方法，而且返回值不是 `NotImplemented`，调用`a.__add__(b)`，然后返回结果。(2) 如果`a`没有`__add__ `方法，或者调用`__add__ `方法返回`NotImplemented`，检查`b`有没有 `__radd__ `方法，如果有，而且没有返回`NotImplemented`，调用`b.__radd__(a)`，然后返回结果。(3) 如果`b`没有`__radd__`方法，或者调用`__radd__`方法返回`NotImplemented`，抛出`TypeError`，并在错误消息中指明操作数类型不支持。

![](../picture/1/43.png)

### 控制流程

可迭代对象：在逻辑上它保存了一个序列，在迭代环境中依次返回序列中的一个元素值。

迭代协议：`.__next__()`方法。任何对象只要实现了迭代协议，则它就是一个迭代器对象，迭代器对象调用`.__next__()`方法，会得到下一个迭代结果，在一系列迭代之后到达迭代器尾部，若再次调用`.__next__()`方法，则会触发`StopIteration`异常，迭代器在Python中是用C语言的速度运行的，因此速度最快  

内置的`iter()`函数用于从序列、字典、`set`以及其他可迭代对象中获取迭代器。对任何迭代器对象`iterator`，调用`iter(iterator)`返回它本身，迭代器对象实现了迭代协议，文件对象本身是一个迭代器对象。即文件对象实现了迭代协议，因此打开多个文件会返回同一个文件对象，列表、元组、字典、`set`、字符串等不适迭代器对象，他们没有实现迭代协议。因此每次调用`iter()`均返回一个新迭代器对象。他们支持安装多个迭代器，每个迭代器状态不同，在原地修改列表、`set`、字典时，会实时反映到它们的迭代器上

`range`对象不支持`.__next__()`，因此它本身不是迭代器，而`map`、`zip`、`filter`对象都是迭代器。字典的视图：键视图、值视图、字典视图都没有`.__next__()`方法，因此他们都不是迭代器  

Python的所有迭代环境都会首先尝试调用`.__iter__(self)`方法，再尝试调用`.__getitem__(self,index)`方法。要让实例对象支持多个迭代器，`.__iter__(self)`方法必须创建并返回新的迭代器对象。

* `.__iter__(self)`方法必须返回一个迭代器对象。Python的迭代环境通过重复调用这个迭代器对象的`.__next__(self)`方法，直到发生了`StopIteration`异常
  * `.__iter__(self)`返回的迭代器对象会在调用`.__next__(self)`
    的过程中明确保留状态信息，因此比`.__getitem__(self,index)`方法具有更好的通用性
  * 迭代器对象没有重载索引表达式，因此不支持随机的索引运算
  * `.__iter__(self)`返回的迭代器只能顺序迭代一次。
    因此每次要进行新的一轮循环时必须创建一个新的迭代器对象
* 对于调用`.__getitem__(self,index)`的环境，Python的迭代环境通过重复调用该方法，其中`index`每轮迭代中从 0 依次递增，直到发生了`IndexError`异常  

类通常把`in`成员关系运算符实现为一个迭代，用`.__iter__(self)`方法或`.__getitem__(self,index)`方法。也能实现`.__contains__(self,value)`方法来实现特定成员关系。

* `.__contains__(self,value)`方法优先于`.__iter__(self)`方法，`.__iter__(self)`方法优先于`.__getitem__(self,index)`方法采纳  

#### 可迭代对象、迭代器和生成器

迭代是数据处理的基石。扫描内存中放不下的数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项。这就是迭代器模式。所有生成器都是迭代器，因为生成器完全实现了迭代器接口。迭代器用于从集合中取出元素；而生成器用于“凭空”生成元素。在Python中，所有集合都可以迭代。在Python语言内部，迭代器用于支持：for循环；构建和扩展集合类型；逐行遍历文本文件；列表推导、字典推导和集合推导；元组拆包；调用函数时，使用`*`拆包实参。

内置的`iter`函数有以下作用。(1) 检查对象是否实现了 `__iter__ `方法，如果实现了就调用它，获取一个迭代器。(2) 如果没有实现 `__iter__ `方法，但是实现了 `__getitem__ `方法，Python 会创建一个迭代器，尝试按顺序从索引 0 开始获取元素。(3) 如果尝试失败，Python 抛出 `TypeError `异常，通常会提示“C object is not `iterable`”，其中`C`是目标对象所属的类。

可迭代的对象使用`iter`内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的`__iter__ `方法，那么对象就是可迭代的。序列都可以迭代；实现了 `__getitem__ `方法，而且其参数是从零开始的索引，这种对象也可以迭代。标准的迭代器接口有两个方法。`__next__`返回下一个可用的元素，如果没有元素了，抛`StopIteration`异常。`__iter__`返回`self`，以便在应该使用可迭代对象的地方使用迭代器

![](../picture/1/38.png)

因为迭代器只需 `__next__ `和 `__iter__ `两个方法，所以除了调用`next()`方法，以及捕获`StopIteration`异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法“还原”迭代器。如果想再次迭代，那就要调用`iter(...)`，传入之前构建迭代器的可迭代对象。传入迭代器本身没用，因为前面说过`Iterator.__iter__ `方法的实现方式是返回实例本身，所以传入迭代器无法还原已经耗尽的迭代器迭代器是这样的对象：实现了无参数的`__next__`方法，返回序列中的下一个元素；如果没有元素了，那么抛出 `StopIteration`异常。Python 中的迭代器还实现了`__iter__ `方法，因此迭代器也可以迭代。可迭代的对象一定不能是自身的迭代器。也就是说，可迭代的对象必须实现`__iter__ `方法，但不能实现 `__next__ `方法。

只要Python函数的定义体中有`yield`关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。生成器函数会创建一个生成器对象，包装生成器函数的定义体。把生成器传给`next(...) `函数时，生成器函数会向前，执行函数定义体中的下一个`yield`语句，返回产出的值，并在**函数定义体的当前位置暂停**。最终，函数的定义体返回时，外层的生成器对象会抛出`StopIteration`异常——这一点与迭代器协议一致。

##### 标准库中的生成器函数

###### 用于过滤的生成器函数

| 函数                                      | 说明                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| `itertools.compress(it, selector_it)`     | 并行处理两个可迭代的对象；如果`selector_it`中的元素是真值，产出`it`中对应的元素 |
| `itertools.dropwhile(predicate, it)`      | 处理`it`，跳过`predicate`的计算结果为真值的元素，然后产出剩下的各个元素 |
| `filter(predicate, it)`                   | 把`it`中的各个元素传给`predicate`，如果`predicate(item)`返回真值，那么产出对应的元素；如果`predicate`是`None`，那么只产出真值元素 |
| `itertools.filterfalse(predicate, it)`    | 与`filter`函数的作用类似，不过`predicate`的逻辑是相反的：`predicate`返回假值时产出对应的元素 |
| `itertools.islice(it, start, stop, step)` | 产出`it`的切片，作用类似于`s[start:stop:step]`，不过`it`可以是任何可迭代的对象，而且这个函数实现的是惰性操作 |
| `itertools.takewhile(predicte, it)`       | `predicate`返回真值时产出对应的元素，然后立即停止，不再继续检查。 |

###### 用于映射的生成器函数

| 函数                              | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `itertools.accumulate(it[,func])` | 产出累积的总和；如果提供了`fun`，那么把前两个元素传给它，然后把计算结果和下一个元素传给它，以此类推，最后产出结果 |
| `enumerate(iterable, start = 0)`  | 产出由两个元素组成的元组，结构是`(index, item)`，其中`index`从`start`开始计数，`item`则从`iterable`中获取 |
| `map(func, it1[, it2, ..., itN])` | 把`it`中的各个元素传给`func`，产出结果；如果传入`N`个可迭代的对象，那么`func`必须能接受`N`个参数，而且要并行处理各个可迭代的对象 |
| `itertools.starmap(func, it)`     | 把`it`中的各个元素传给`func`，产出结果；输入的可迭代对象应该产出可迭代的元素`iit`，然后以`func(*iit)`这种形式调用`func` |

###### 合并多个可迭代对象的生成器函数

| 函数                                                   | 说明                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| `itertools.chain(it1, ..., itN)`                       | 先产出`it1`中的所有元素，然后产出`it2`中的所有元素，以此类推，无缝连接在一起 |
| `itertools.chain.from_iterable(it)`                    | 产出`it`生成的各个可迭代对象中的元素，一个接一个，无缝连接在一起；`it`应该产出可迭代的元素。 |
| `itertools.product(it1, ..., itN, repeat =1)`          | 计算笛卡儿积：从输入的各个可迭代对象中获取元素，合并成由 `N`个元素组成的元组，与嵌套的`for`循环效果一样；`repeat`指明重复处理多少次输入的可迭代对象 |
| `zip(it1, ..., itN)`                                   | 并行从输入的各个可迭代对象中获取元素，产出由`N`个元素组成的元组，只要有一个可迭代的对象到头了，就默默地停止 |
| `itertools.zip_longest(it1, ..., itN, fillvalue=None)` | 并行从输入的各个可迭代对象中获取元素，产出由`N`个元素组成的元组，等到最长的可迭代对象到头后才停止，空缺的值使用`fillvalue`填充 |

###### 把输入的各个元素扩展成多个输出元素的生成器函数

| 函数                                                   | 说明                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| `itertools.combination(it, out_len)`                   | 把`it`产出的`out_len`个元素组合在一起，然后产出              |
| `itertools.combinations_with_replacement(it, out_len)` | 把`it`产出的`out_len`个元素组合在一起，然后产出，包含相同元素的组合 |
| `itertools.count(start=0, step=1)`                     | 从`start`开始不断产出数字，按`step`指定的步幅增加            |
| `itertools.cycle(it)`                                  | 从`it`中产出各个元素，存储各个元素的副本，然后按顺序重复不断地产出各个元素 |
| `itertools.permutation(it, out_len=None)`              | 把`out_len`个`it`产出的元素排列在一起，然后产出这些排列；`out_len`的默认值等于`len(list(it))` |
| `itertools.repeat(item[, times])`                      | 重复不断地产出指定的元素，除非提`times`，指定次数            |

###### 用于重新排列元素的生成器函数

| 函数                                  | 说明                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| `itertools.groupby(iter, key = None)` | 产出由两个元素组成的元素，形式为`(key, group)`，其中`key`是分组标准，`group`是生成器，用于产出分组里的元素 |
| `reversed(seq)`                       | 从后向前，倒序产出`seq`中的元素；`seq`必须是序列，或者是实现了`__reversed__`特殊方法的对象 |
| `itertools.tee(it, n =2)`             | 产出一个由`n`个生成器组成的元组，每个生成器用于单独产出输入的可迭代对象中的元素 |

###### 读取迭代器，返回单个值的内置函数

| 函数                                    | 说明                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| `any(it)`                               | 只要`it`中有元素为真值就返回`True`，否则返回`False`；`any([])`返回`False` |
| `all(it)`                               | `it`中的所有元素都为真值时返回`True`，否则返回`False`；`all([])`返回`True` |
| `max(it[, key, default])`               | 返回`it`中值最大的元素；`key`是排序函数；如果可迭代的对象为空，返回`default` |
| `min(it[, key, default])`               | 返回`it`中值最小的元素；`key`是排序函数；如果可迭代的对象为空，返回`default` |
| `functools.reduce(func, it[, initial])` | 把前两个元素传给`func`，然后把计算结果和第三个元素传给 `func`，以此类推，返回最后的结果；如果提供了`initial`，把它当作第一个元素传入 |
| `sum(it, start = 0)`                    | `it`中所有元素的总和，如果提供可选的`start`，会把它加上      |

`iter`函数还有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调用的对象创建迭代器。这样使用时，第一个参数必须是可调用的对象，用于不断调，产出各个值；第二个值是哨符，这是个标记值，当可调用的对象返回这个值时，触发迭代器抛出`StopIteration`异常，而不产出哨符。

```python
#逐行读取文件，直到遇到空行或者到达文件末尾为止
with open('mydata.txt') as fp:
    for line in iter(fp.readline, '\n'):
        process_line(line)
```

#### 上下文管理和`else`块

`with/as`语句。它是作为`try/finally`的替代方案。用法为：

```
with expression [as var]:
	statements
```

`expression`必须返回一个对象，该对象必须支持环境管理协议。其工作方式为：计算`expression`表达式的值，得到环境管理器对象。环境管理器对象必须有`.__enter__(self)`方法和`.__exit__(self, exc_type, exc_value, traceback)`方法；调用环境管理器对象的`.__enter__(self)`方法。如果有`as`子句，`.__enter__(self)`方法返回值赋值给`as`子句中的变量`var`；如果没有`as`子句，则`.__enter__(self)`方法返回值直接丢弃；执行`statements`代码块；如果`statements`代码块抛出异常，则`.__exit__(self, exc_type, exc_value, traceback)`方法自动被调用；若`.__exit__()`方法返回值为`False`，则重新抛出异常到`with`语句之外；若`.__exit__()`方法返回值为`True`，则异常终止于此，并不会抛出`with`语句之外；如果`statements`代码块未抛出异常，则`.__exit__(self, exc_type, exc_value, traceback)`方法自动被调用，调用参数为：`.__exit__(self,None,None,None)`

`with`语句可以指定多个环境管理器，以逗号分隔。根据定义的顺序这些环境管理器对象的`.__enter__(self)`方法顺序调用，`.__exit__(self, exc_type, exc_value, traceback)`方法逆序调用

`for/else、while/else `和 `try/else `的语义关系紧密，不过与`if/else`差别很大。`for`仅当 `for `循环运行完毕时才运行`else`块。`while`仅当`while`循环因为条件为假值而退出时才运行`else`块。`try`仅当`try `块中没有异常抛出时才运行`else`块。在所有情况下，如果异常或者`return、break`或`continue`语句导致控制权跳到了复合
语句的主块之外，`else`子句也会被跳过。

上下文管理器对象存在的目的是管理`with`语句，就像迭代器的存在是为了管理`for`语句一样。`with`语句的目的是简化`try/finally `模式。这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、`return `语句或 `sys.exit() `调用而中止，也会执行指定的操作。`finally `句中的代码通常用于释放重要的资源，或者还原临时变更的状态。上下文管理器协议包含 `__enter__ `和 `__exit__ `两个方法。`with `语句开始运行时，会在上下文管理器对象上调用 `__enter__ `方法。`with `语句运行结束后，会在上下文管理器对象上调用 `__exit__ `方法，以此扮演`finally`子句的角色。执行`with`后面的表达式得到的结果是上下文管理器对象，不过，把值绑定到目标变量上是在上下文管理器对象上调用` __enter__ `方法的结果。

`@contextmanager `装饰器能减少创建上下文管理器的样板代码量，因为不用编写一个完整的类，定义 `__enter__ `和 `__exit__ `方法，而只需实现有一个`yield`语句的生成器，生成想让 `__enter__ `方法返回的值。
在使用` @contextmanager `装饰的生成器中，`yield `语句的作用是把函数的定义体分成两部分：`yield `语句前面的所有代码在`with`块开始时即解释器调用 `__enter__ `方法时执行， `yield`语句后面的代码在`with`块结束时即调用 `__exit__ `方法时执行。其实，`contextlib.contextmanager `装饰器会把函数包装成实现 `__enter__ `和
`__exit__ `方法的类。这个类的 `__enter__ `方法有如下作用。调用生成器函数，保存生成器对象。调用 `next(gen)`，执行到`yield`关键字所在的位置。返回`next(gen)`产出的值，以便把产出的值绑定到`with/as`语句中的目标变量上。with 块终止时，`__exit__ `方法会做以下几件事。检查有没有把异常传给`exc_type`；如果有，调用`gen.throw(exception)`，在生成器函数定义体中包含`yield`关键字的那一行抛出异常。否则，调用 `next(gen)`，继续执行生成器函数定义体中`yield`语句之后的代码`。

#### 协程

##### 把生成器当成协程

生成器函数：编写为常规的`def`语句，但是用`yield`语句一次返回一个结果。每次使用生成器函数时会继续上一轮的状态。生成器函数会保存上次执行的状态，生成器函数执行时，得到一个生成器对象，它`yield`一个值，而不是返回一个值。生成器对象自动实现迭代协议，它有一个`.__next__()`方法，对生成器对象调用`.__next__()`方法会继续生成器函数的运行到下一个`yield`结果或引发一个`StopIteration`异常。`yield`语句会挂起生成器函数并向调用者发送一个值。当下一轮继续时，函数会在上一个`yield`表达式返回后继续执行，其本地变量根据上一轮保持的状态继续使用，生成器对象有一个`.send(arg)`方法。该方法会将`arg`参数发送给生成器作为`yield`表达式的返回值，同时生成器会触发生成动作(相当于调用了一次`.__next__()`方法。`yield`表达式的返回值和生成值是不同的。返回值是用于生成器函数内部，`yield`表达式默认返回值为`None`；而生成值是用于生成器函数外部的迭代返回。生成器对象必须先启动。启动意味着它第一次运行到`yield`之前挂起    要想启动生成器，可以直接使用`next(generatorable)`函数，也可以使用`generatorable.send(None)`方法，或者
`generatorable.__next__()`方法，`generatorable.send(None)`方法会在传递`yield`表达式的值（默认为`None`返回值），下一轮迭代从`yield`表达式返回开始。每一轮挂起时，`yield`表达式 yield 一个数，但是并没有返回（挂起了该`yield`表达式。生成器函数可以有`return`，它可以出现在函数内任何地方。生成器函数内遇到`return`则触发`StopIteration`异常，同时`return`的值作为异常说明 。可以调用生成器对象的`.close()`方法强制关闭它。这样再次给它`send()`任何信息，都会抛出`StopIteration`异常，表明没有什么可以生成的了  

```python
def generator():
    inner_gen=generator2()
    yield from inner_gen #为了便于说明，这里分两行写
gen=generator()
```

对`inner_gen`迭代产生的每个值都直接作为`gen` yield值，所有`gen.send(val)`发送到`gen`的值`val`都会被直接传递给`inner_gen`。`inner_gen`抛出异常：如果`inner_gen`产生了`StopIteration`异常，则`gen`会继续执行`yield from`之后的语句；如果对`inner_gen`产生了非`StopIteration`异常，则传导至`gen`中，导致`gen`在执行`yield from`的时候抛出异常，`gen`抛出异常：如果`gen`产生了除`GeneratorExit`以外的异常，则该异常直接 throw 到`inner_gen`中；如果`gen`产生了`GeneratorExit`异常，或者`gen`的`.close()`方法被调用，
则`inner_gen`的`.close()`方法被调用。`gen`中`yield from`表达式求职结果是`inner_gen`迭代结束时抛出的`StopIteration`异常的第一个参数，`inner_gen`中的`return xxx`语句实际上会抛出一个`StopIteration(xxx)`异常，所以`inner_gen`中的`return`值会成为`gen`中的`yield from`表达式的返回值。

与` .__next__() `方法一样，`.send() `方法致使生成器前进到下一个`yield`语句。不过，`.send() `方法还允许使用生成器的客户把数据发给自己，即不管传给 `.send() `方法什么参数，那个参数都会成为生成器函数定义体中对应的`yield`表达式的值。也就是说`.send()`方法允许在客户代码和生成器之间双向交换数据。而 `.__next__() `方法只允许客户从生成器中获取数据。

`yield item`这行代码会产出一个值，提供给`next(...)`的调用方；此外，还会作出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用`next()`。调用方会从生成器中拉取值。从句法上看，协程与生成器类似，都是定义体中包含 yield 关键字的函数。可是，在协程中，`yield`通常出现在表达式的右边，如`datum = yield`，可以产出值，也可以不产出——如果 yield 关键字后面没有表达式，那么生成器产出`None`。协程可能会从调用方接收数据，不过调用方把数据提供给协程使用的是 `.send(datum) `方法，而不是`next(...) `函数。通常，调用方会把值推送给协程。
`yield`关键字甚至还可以不接收或传出数据。不管数据如何流动，yield 都是一种流程控制工具，使用它可以实现协作式多任务：协程可以把控制器让步给中心调度程序，从而激活其他的协程。从根本上把`yield`视作控制流程的方式，这样就好理解协程了。

协程可以身处四个状态中的一个。当前状态可以使用`inspect.getgeneratorstate(...)`函数确定，该函数会返回下述字符串中的一个。`'GEN_CREATED'`: 等待开始执行。`'GEN_RUNNING'`: 解释器正执行。`'GEN_SUSPENDED'`: 在 yield 表达式处暂停。`'GEN_CLOSED'`:执行结束。因为` send `方法的参数会成为暂停的`yield`表达式的值，所以，仅当协程处于暂停状态时才能调用`send`方法。不过，如果协程还没激活，情况就不同了。因此，始终要调用 `next(my_coro)` 激活协，效果一样。

![](../picture/1/39.png)

协程中未处理的异常会向上冒泡，传给`next`函数或`send`方法的调用方。客户代码可以在生成器对象上调用两个方法，显式地把异常发给协程。这两个方法是`throw`和`close`。`generator.throw(exc_type[, exc_value[, traceback]])`致使生成器在暂停的`yield`表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个`yield`表达式，而产出的值会成为调用`generator.throw`方法得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。`generator.close()`致使生成器在暂停的`yield`表达式处抛出`GeneratorExit`异常。如果生成器没有处理这个异常，或者抛出了`StopIteration`异常，调用方不会报错。如果收到`GeneratorExit`异常，生成器一定不能产出值，否则解释器会抛出`RuntimeError `异常。生成器抛出的其他异常会向上冒泡，传给调用方。

在生成器`gen`中使用`yield from subgen()`时，`subgen`会获得控制权，把产出的值传给`gen`的调用方，即调用方可以直接控制`subgen`。与此同时，`gen`会阻塞，等待`subgen`终止。`yield from x`表达式对`x`对象所做的第一件事是，调用`iter(x)`，从中获取迭代器。因此，`x`可以是任何可迭代的对象。`yield from`的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。有了这个结构，协程可以通过以前不可能的方式委托职责。

委派生成器：包含`yield from <iterable>`表达式的生成器函数。子生成器：从 yield from 表达式中`<iterable>`部分获取的生成器。调用方指代调用委派生成器的客户端代码。

![](../picture/1/40.png)

```python
from collections import namedtuple
Result = namedtuple('Result', 'count average')
def averager():
    total, count, average = 0., 0, None
    while True:
        term = yield
        if term is None:
            break
        total += term
        count += 1
        average total/count
    return Result(count, average)
def grouper(results, key): # 委派生成器
    while True:
        results[key] = yield from averager()
def main(data):
    results = {}
    for key, values in data.items():
        group = grouper(results, key) 
        next(group) 
        for value in values:
            group.send(value)
        group.send(None)
```

外层`for`循环每次迭代会新建一个`grouper`实例，赋值给`group`变量；`group`是委派生成器。调用`next(group)`，预激委派生成器`grouper`，此时进入`while True`循环，调用子生成器`averager`后，在`yield from`表达式处暂停。内层`for`循环调用`group.send(value)`，直接把值传给子生成器`averager`。同时，当前的`grouper`实例`group`在`yield from`表达式处暂停。内层循环结束后，`group`实例依旧在`yield from`表达式处暂停，因此，`grouper`函数定义体中为`results[key]`赋值的语句还没有执行。如果外层`for`循环的末尾没有 `group.send(None)`，那么`averager`子生成器永远不会终止，委派生成器`group`永远不会再次激活，因此永远不会为`results[key]`赋值。外层`for`循环重新迭代时会新建一个`grouper`实例，然后绑定到`group`变量上。前一个`grouper`实例以及它创建的尚未终止的`averager`子生成器实例被垃圾回收程序回收。

###### `yield from`的意义

子生成器产出的值都直接传给委派生成器的调用方即客户端代码。使用`send()`方法发给委派生成器的值都直接传给子生成器。如果发送的值是`None`，那么会调用子生成器的 `__next__() `方法。如果发送的值不是 None，那么会调用子生成器的`send()`方法。如果调用的方法抛出`StopIteration`异常，那么委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。生成器退出时，生成器或子生成器中的` return expr `表达式会触发
`StopIteration(expr) `异常抛出。`yield from `表达式的值是子生成器终止时传给 `StopIteration `异常的第一个参数。`yield from `结构的另外两个特性与异常和终止有关。传入委派生成器的异常，除了` GeneratorExit `之外都传给子生成器的 throw() 方法。如果调用` throw() `方法时抛出 `StopIteration `异常，委派生成器恢复运
行。`StopIteration `之外的异常会向上冒泡，传给委派生成器。如果把 `GeneratorExit `异常传入委派生成器，或者在委派生成器上调用 `close() `方法，那么在子生成器上调用 `close() `方法，如果它有的话。如果调用 `close() `方法导致异常抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出`GeneratorExit `异常。

假设`yield from`出现在委派生成器中。客户端代码驱动着委派生成器，而委派生成器驱动着子生成器。那么，为了简化涉及到的逻辑，我们假设客户端没有在委派生成器上调用`.throw(...)`或`.close()`方法。此外，我们还假设子生成器不会抛出异常，而是一直运行到终止，让解释器抛出`StopIteration`异常。下面的伪代码，等效于委派生成器中的`RESULT = yield from EXPR`语句

```python
_i = iter(EXPR)
try:
    _y = next(_i)
    # 预激子生成器；结果保存在 _y 中，作为产出的第一个值。
except StopIteration as _e:
    _r = _e.value
else:
    while 1:
        _s = yield _y
        #产出子生成器当前产出的元素；等待调用方发送 _s 中保存的值。
        try:
            # 尝试让子生成器向前执行，转发调用方发送的 _s。
            _y = _i.send(_s)
        except StopIteration as _e:
            _r = _e.value
            break
RESULT = _r
```

`_i`迭代器：子生成器；`_y`产出的值：子生成器产出的值；`_r`结果：最终的结果即子生成器运行结束后`yield from`表达式的值；`_s`发送的值：调用方发给委派生成器的值，这个值会转发给子生成器；`_e`异常：异常对象

##### 使用`futures`处理并发

###### 线程和进程

单核CPU是怎么执行多任务的呢？答案就是操作系统轮流让各个任务交替执行。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。对于操作系统来说，一个任务就是一个进程，比如打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程。有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查等事情。在一个进程内部，要同时干多件事，就需要同时运行多个子任务，我们把进程内的这些 子任务称为线程。由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换交替运行。当然，真正地同时执行多线程需要多核CPU才可能实现。多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。

Python全局解释锁GIL简单来说就是一个互斥体，这样的机制只允许一个线程来控制Python解释器。这就意味着在任何一个时间点只有一个线程处于执行状态。GIL对执行单线程任务的程序员们来说并没什么显著影响，但是它成为了计算密集型和多线程任务的性能瓶颈。
Python利用**引用计数来进行内存管理**，这就意味着在Python中创建的对象都有一个引用计数变量来追踪指向该对象的引用数量。当数量为0时，该对象占用的内存即被释放。问题在于，这个引用计数变量需要在两个线程同时增加或减少时从竞争条件中得到保护。如果发生了这种情况，可能会导致泄露的内存永远不会被释放，抑或更严重的是当一个对象的引用仍然存在的情况下错误地释放内存。通过对跨线程分享的数据结构添加锁定以至于数据不会不一致地被修改，这样做可以很好的保证引用计数变量的安全。GIL是解释器本身的一个单一锁，它增加的一条规则表明任何Python字节码的执行都需要获取解释锁。这有效地防止了死锁并且不会带来太多的性能开销。但是这的确使每一个计算密集型任务变成了单线程。
**计算密集型任务**是那些促使CPU达到极限的任务。这其中包括了进行数学计算的程序，如矩阵相乘、搜索、图像处理等。**I/O密集型任务**是一些需要花费时间来等待来自用户、文件、数据库、网络等的输入输出的任务。I/O密集型任务有时需要等待非常久直到他们从数据源获取到他们所需要的内容为止。这是因为在准备好输入输出之前数据源本身需要先进行自身处理GIL对I/O密集型任务多线程程序的性能没有太大的影响，因为在等待I/O时锁可以在多线程之间共享。

为了高效处理网络 I/O，需要使用并发，因为网络有很高的延迟，所以为了不浪费 CPU 周期去等待，最好在收到网络响应之前做些其他的事。

###### 使用`concurrent.futures`模块下载

`concurrent.futures`模块的主要特色是`ThreadPoolExecutor`和`ProcessPoolExecutor`类，这两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。这两个类在内部维护着一个工作线程或进程池，以及要执行的任务队列。

```python
from concurrent import futures
'''使用工作的线程数实例化 ThreadPoolExecutor 类；executor.__exit__ 方法会调用 executor.shutdown(wait=True) 方法，它会在所有线程都执行完毕前阻塞线程。'''
def download_many(cc_list):
    workers = len(cc_list)
    with futures.ThreadPoolExecutor(workers):
        '''map方法的作用与内置的map函数类似，不过func函数会在多个线程中并发调用；map方法返回一个生成器，因此可以迭代，获取各个函数返回的值。'''
        res = executor.map(func, data)
        '''返回获取的结果数量；如果有线程抛出异常，异常会在这里抛出，这与隐式调用next()函数从迭代器中获取相应的返回值一样。'''
     return len(list(res))
```

```python
def download_many(cc_list):
    with futures.ThreadPoolExecutor(len(cc_list)) as executor:
        '''executor.submit 方法排定可调用对象的执行时间，然后返回一个期物，表示这个待执行的操作。'''
        submit = (executor.submit(func, cc) for cc in cc_list)
        '''as_completed 函数在期物运行结束后产出期物。'''
        res = (future.result() for future in futures.as_completed(submit))
    return len(list(result))
 
```

标准库中有两个名为`Future`的类：`concurrent.futures.Future`和`asyncio.Future`。这两个类的作用相同：两个`Future`类的实例都表示可能已经完成或者尚未完成的延迟计算。期物封装待完成的操作，可以放入队列，完成的状态可以查询，得到结果后可以获取结果。我们要记住一件事：通常情况下自己不应该创建期物，而只能由并发框架`concurrent.futures`或`asyncio`实例化。原因很简单：期物表示终将发生的事情，而确定某件事会发生的唯一方式是执行的时间已经排定。因此，只有排定把某件事交给`concurrent.futures.Executor`子类处理时，才会创建`concurrent.futures.Future`实例。客户端代码不应该改变期物的状态，并发框架在期物表示的延迟计算结束后会改变期物的状态，而我们无法控制计算何时结束。这两种期物都有`.done()`方法，这个方法不阻塞，返回值是布尔值，指明期物链接的可调对象是否已经执行。客户端代码通常不会询问期物是否运行结束，而是会等待通知。因此，两个`Future`类都有`.add_done_callback()`方法：这个方法只有一个参数，类型是可调用的对象，期物运行结束后会调用指定的可调用对象。此外，还有`.result()`方法。在期物运行结束后调用的话，这个方法在两个`Future`类中的作用相同：返回可调用对象的结果，或者重新抛出执行可调用的对象时抛出的异常。可是，如果期物没有运行结束，`result`方法在两个`Future`类中的行为相差很大。对`concurrency.futures.Future` 实例来说，调用`f.result()`方法会阻塞调用方所在的线程，直到有结果可返回。此时，`result`方法可以接收可选的`timeout`参数，如果在指定的时间内期物没有运行完毕，会抛出 `TimeoutError`异常。

###### 阻塞型`I/O`和`GIL`

`CPython`解释器本身就不是线程安全的，因此有全局解释器锁，一次只允许使用一个线程执行Python字节码。因此，一个Python进程通常不能同时使用多个CPU核心。标准库中所有执行阻塞型 I/O 操作的函数，在等待操作系统返回结果时都会释放`GIL`。这意味着在Python语言这个层次上可以使用多线程，而`I/O`密集型Python程序能从中受益：一个Python线程等待网络响应时，阻塞型I/O函数会释放GIL，再运行一个线程。`concurrent.futures`模块实现的是真正的并行计算，因为它使用`ProcessPoolExecutor`类把工作分配给多个`Python`进程处理。因此，如果需要做`CPU`密集型处理，使用这个模块能绕开`GIL`，利用所有可用的`CPU`核心。`ProcessPoolExecutor`和`ThreadPoolExecutor`类都实现了通用的`Executor`接口，因此使用`concurrent.futures`模块能特别轻松地把基于线程的方案转成基于进程的方案。对简单的用途来说，这两个实现`Executor`接口的类唯一值得注意的区别
是，`ThreadPoolExecutor.__init__ `方法需要`max_workers`参数，指定线程池中线程的数量。在 `ProcessPoolExecutor`类中，那个参数是可选的，而且大多数情况下不使用——默认值是`os.cpu_count()`函数返回的`CPU`数量。这样处理说得通，因为对`CPU`密集型的处理来说，不可能要求使用超过`CPU`数量的进程。而对`I/O`密集型处理来说，可以在一个`ThreadPoolExecutor`实例中使用10个、100个或1000个线程；最佳线程数
取决于做的是什么事，以及可用内存有多少。`executor.submit`和`futures.as_completed`这个组合比`executor.map`更灵活，因为`submit`方法能处理不同的可调用对象和参数，而`executor.map`只能处理参数不同的同一个可调用对象。此外，传给`futures.as_completed`函数的期物集合可以来自多个`Executor`实例，例如一些由`ThreadPoolExecutor`实例创建，另一些由`ProcessPoolExecutor`实例创建。

而协程默认会做好全方位保护，以防止中断。我们必须显式产出才能让程序的余下部分运行。对协程来说，无需保留锁，在多个线程之间同步操作，协程自身就会同步，因为在任意时刻只有一个协程运行。想交出控制权时，可以使用`yield`或`yield from`把控制权交还调度程序。这就是能够安全地取消协程的原因：按照定义，协程只能在暂停的`yield`处取消，因此可以处理`CancelledError`异常，执行清理操作。期物只是调度执行某物的结果。在 `asyncio`包中，`BaseEventLoop.create_task(...)`方法接收一个协程，排定它的运行时间，然后返回一个`asyncio.Task`实例——也是`asyncio.Future`类的实例，因为`Task`是`Future`的子类，用于包装协程。这与调用`Executor.submit(...)`方法创建`concurrent.futures.Future`实例是一个道理。与 `concurrent.futures.Future`类似，`asyncio.Future`类也提供了`.done()、.add_done_callback(...)`和`.result()`等方法。前两个方法的用法一样，不过`.result()`方法差别很大。`asyncio.Future`类的`.result()`方法没有参数，因此不能指定超时时间。此外，如果调用`.result()`方法时期物还没运行完毕，那么`.result()`方法不会阻塞去等待结果，而是抛出`asyncio.InvalidStateError`异常。然而，获取 `asyncio.Future`对象的结果通常使用`yield from`，从中产出结果。使用`yield from`处理期物，等待期物运行完毕这一步无需我们关心，而且不会阻塞事件循环，因为在`asyncio`包中，`yield from`的作用是把控制权还给事件循环。使用`yield from`处理期物与使用`add_done_callback`方法处理协程的作用一样：延迟的操作结束后，事件循环不会触发回调对象，而是设置期物的返回值；而`yield from`表达式则在暂停的协程中生成返回值，恢复执行协程。总之，因为`asyncio.Future`类的目的是与`yield from`一起使用，所以通常不需要使用以下方法。
无需调用`my_future.add_done_callback(...)`，因为可以直接把想在期物运行结束后执行的操作放在协程中 `yield from my_future`表达式的后面。这是协程的一大优势：协程是可以暂停和恢复的函数。无需调用 `my_future.result()`，因为`yield from`从期物中产出的值就是结果。当然，有时也需要使用 `.done()、.add_done_callback(...)`和`.result()`方法。但是一般情况下，`asyncio.Future`对象由`yield from`驱动，而不是靠调用这些方法驱动

在`asyncio`包中，期物和协程关系紧密，因为可以使用`yield from`从`asyncio.Future`对象中产出结果。这意味着，如果`foo`是协程函数（调用后返回协程对象），抑或是返回`Future`或`Task`实例的普通函数，那么可以这样写：`res = yield from foo()`。为了执行这些操作，必须排定协程的运行时间，然后使用`asyncio.Task`对象包装协程。对协程来说，获取`Task`对象有两种主要方式。`asyncio.async(coro_or_future, *, loop=None)`这个函数统一了协程和期物：第一个参数可以是二者中的任何一个。如果是`Future`或`Task`对象，那就原封不动地返回。如果是协程，那么`async`函数会调用`loop.create_task(...)`方法创建`Task`对象。loop= 关键字参数是可选的，用于传入事件循环；如果没有传入，那么`async`函数会通过调用`asyncio.get_event_loop()`函数获取循环对象。`BaseEventLoop.create_task(coro)`这个方法排定协程的执行时间，返回一个`asyncio.Task`对象。如果在自定义的`BaseEventLoop`子类上调用，返回的对象可能是外部库中与 Task 类兼容的某个类的实例。

有两种方法能避免阻塞型调用中止整个应用程序的进程：在单独的线程中运行各个阻塞型操作；把每个阻塞型操作转换成非阻塞的异步调用使用。多个线程是可以的，但是各个操作系统线程消耗的内存达兆字节。如果要处理几千个连接，而每个连接都使用一个线程的话，我们负担不起。为了降低内存的消耗，通常使用回调来实现异步调用。这是一种低层概念，类似于所有并发机制中最古老、最原始的那种——硬件中断。使用回调时，我们不等待响应，而是注册一个函数，在发生某件事时调用。这样，所有调用都是非阻塞的。因为回调简单

当然，只有异步应用程序底层的事件循环能依靠基础设置的中断、线程、轮询和后台进程等，确保多个并发请求能取得进展并最终完成，这样才能使用回调。 事件循环获得响应后，会回过头来调用我们指定的回调。不过，如果做法正确，事件循环和应用代码共用的主线程绝不会阻塞。

把生成器当作协程使用是异步编程的另一种方式。对事件循环来说，调用回调与在暂停的
协程上调用 .send() 方法效果差不多。各个暂停的协程是要消耗内存，但是比线程消耗
的内存数量级小。而且，协程能避免可怕的“回调地狱”；

### 元编程

管理属性的工具：`.__getattr__(self,name)`方法：拦截所有未定义属性的读取（它要么返回一个值，要么抛出`AttributeError`异常；`.__setattr__(self,name,value)`方法：拦截所有属性的读取赋值；`.__getattribute__(self,name)`方法：拦截所有属性的读取；`property`特性：将特定属性访问定位到`get`方法和`set`方法；描述符协议：将特定属性访问定位到具有任意`get`和`set`方法的实例对象

`property`：每个`property`管理一个单一的、特定的属性。用法为：

```python
class A:	
	def fget(...):
		pass
	def fset(...):
		pass
	def fdel(...):
		pass
	attribute=property(fget,fset,fdel,"doc")  #必须在fget,fset,fdel之后定义
a=A()
a.attribute #调用的是property特性
```

`property()`函数返回的是一个`property`对象，子类继承了超类的`property`，就和类的普通属性一样

描述符：描述符是作为独立的类创建，它的实例是赋值给了类属性，描述符的实例可以由子类继承，描述符的实例管理一个单一的特定的属性，从技术上讲，`property()`创建的是一个描述符实例，描述符实例针对想要拦截的属性名访问操作，它提供了特定的方法。描述符类的接口为（即描述符协议）：

```python
class Descriptor:
	def __get__(self,instance,owner):
		pass
	def __set__(self,instance,value):
		pass
	def __delete__(self,instance):
		pass
class A:
	attr=Descriptor()
	...
```

* `instance`参数为：`None`：当用于类的属性访问时；类`A`的实例对象：当用于实例的属性访问时
* `owner`参数为：使用该描述符的类`A`
* 当访问类实例或者类属性时，自动调用该类的描述符实例的方法。如果该类的描述符中某些方法空缺则：若` __set__(self,instance,value)`未定义，则写该属性抛出`AttributeError`，该属性只读；若` __get__(self,instance,owner)`未定义，则读该属性返回一个`Descriptor`实例，因为从继承树中可知，该属性返回由类的`attr`变量名指定的对象
* 状态信息可以保持在实例对象中，也可以保存在描述符实例中。因为在这3个方法中，`self`,`instance`都可以访问

`.__delattr__(self,name)`方法拦截属性的删除

由于`.__getattribute__(self,name)`方法和`.__setattr__(self,name,value)`方法对所有的属性拦截，因此他们的实现特别要小心，注意不要触发无穷递归。

* `.__getattribute__(self,name)`方法中，若要取属性则可以用超类的`.__getattribute__(self,name)`获取。如果通过`.__dict__`方法获取则会再次触发`.__getattribute__(self,name)`的调用，因为`__dict__`本身就是对象的属性。
* `.__setattr__(self,name,value)`方法中，若要设置属性可以用`self.__dict__[name]=value`的方法，或者用超类的`.__setattr__(self,name,value)`方法
* 所有使用内置操作隐式的获取方法名属性，`.__getattr__(self,name)`、`.__setattr__(self,name,value)`、
  `.__getattribute__(self,name)`方法都不会拦截，因为Python在类中查找这样的属性，完全忽略了在实例中查找

属性拦截优先级：在读取属性方面，`__getattribute__`优先级最高；在写属性方面，`__setattr__`优先级最高；在删除属性方面，`__del__`优先级最高；如果没有`__getattribute__`，`__setattr__`与`__del__`，则读写删属性取决于描述符（`property`也是一种特殊的描述符）。其中如果同一个属性指定了多个描述符，则后面的描述符覆盖前面的描述符；`__getattribute__`与`__getattr__`区别：`__getattribute__`在任何属性读取的时候拦截，而`__getattr__`只有在未定义属性读取的时候拦截（约定俗成地，它要么返回一个值，要么返回`AttributeError`）。其中若二者同时存在则`__getattribute__`优先级较高

描述符的作用是用来代理一个类的属性，需要注意的是描述符不能定义在被使用类的构造函数中，只能定义为类的属性，它只属于类的，不属于实例。类的`__dict__`属性是类的一个内置属性，类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类`__dict__`里。在输出描述符的变量时，会调用描述符中的`__get__`方法，在设置描述符变量时，会调用描述符中的`__set__`方法。

 描述符分为数据描述符和非数据描述符。至少实现了内置`__set__()`和`__get__()`方法的描述符称为数据描述符；实现了除`__set__()`()以外的方法的描述符称为非数据描述符。描述符的优先级的高低顺序：类属性 > 数据描述符 > 实例属性 > 非数据描述符 > 找不到的属性触发`__getattr__()`。

函数在使用@property 装饰器装饰后，会变成类属性，而且会有一个 setter 方法，该方法也是一个装饰器，作用是装饰同属性(特性)的 set 函数。被装饰的函数必须与属性（被@property 装饰器装饰的函数）同名。当类函数被 @property 装饰时，实际上，这个函数已经成为了该类的特性，也就是该类的类属性了，这个过程在解释器导入该模块时就已经确定了。

#### 动态属性和特性

在 Python 中，数据的属性和处理数据的方法统称属性attribute。其实，方法只是可调用的属性。除了这二者之外，我们还可以创建特性property，在不改变类接口的前提下，使用存取方法即读值方法和设值方法修改数据属性仅当无法使用常规的方式获取属性即在实例、类或超类中找不到指定的属性，解释器才会调用特殊的 `__getattr__ `方法。

```python
from collections import abc
class FrozenJSON:
    def __new__(cls, arg):
        if isintance(arg, abc.Mapping):
            return super().__new__(cls)
        elif isinstance(arg, abc.MutableSequence):
            return [cls(item) for item in arg]
        else: return arg
    def __init__(self, mapping):
        self._data = dict(mapping)
    def __getattr__(self, name):
        if hasattr(self._data, name):
            return getattr(self._data, name)
        else:
            return FrozenJSON(self._data[name])
   ''' @classmethod
    def build(cls, obj):
        if isinstance(obj, abc.Mapping):
            return cls(obj)
        elif isinstance(obj, abc.MutableSequence):
            return [cls(item) for item in obj]
        else:
            return obj'''
```

`rozenJSON`类只有两个方法`__init__ `和 `__getattr__`和一个实例属性`__data`。因此，尝试获取其他属性会触发解释器调用`__getattr__`方法。这个方法首先查看`self.__data`字典有没有指定名称的属性不是键，这样`FrozenJSON`实例便可以处理字典的所有方法。如果`self.__data`没有指定名称的属性，那么`__getattr__ `方法以那个名称为键，从`self.__data`中获取一个元素，传给`FrozenJSON.build`方法。这样就能深入`JSON `数据的嵌套结构，使用类方法`build`把每一层嵌套转换成一个`FrozenJSON`实例。

我们通常把`__init__`称为构造方法。其实，用于构建实例的是特殊方法`__new__`：这是个类方法使用特殊方式处理，因此不必使用`@classmethod`装饰器，必须返回一个实例。返回的实例会作为第一个参数即self传给`__init__`方法。因为调用`__init__`方法时要传入实例，而且禁止返回任何值，所以`__init__`方法其实是“初始化方法”。真的构造方法是`__new__`。我们几乎不需要自己编写`__new__`方法，因为从`object`类继承的实现已经足够了。刚才说明的过程，即从`__new__`方法到`__init__`方法，是最常见的，但不是唯一的。`__new__`方法也可以**返回其他类的实例**，此时，解释器不会调用 `__init__ `方法。

```python
def object_maker(the_class, args):
    new_obj = the_class.__new__(args)
    if isinstance(new_obj, the_class):
        the_class.__init__(new_obj, args)
    return new_obj
x = Foo('bar')#两个语句的作用基本等效
x = object_maker(Foo, 'bar')
```

##### 使用动态属性转换数据类型

##### 特性全解析

`property(fget=None, fset=None, fdel=None, doc=None)`所有参数都是可选的，如果没有把函数传给某个参数，那么得到的特性对象就不允许执行相应的操作。特性都是类属性，但是特性管理的其实是实例属性的存取。实例属性不会遮盖类特性。新添的类特性遮盖现有的实例属性。`obj.attr`这样的表达式不会从`obj`开始寻找`attr`，而是从`obj.__class__`开始，而且，仅当类中没有名为`attr`的特性时，Python才会在`obj`实例中寻找。这条规则不仅适用于特性，还适用于一整类描述符——覆盖型描述符。

描述符是实现了特定协议的类，这个协议包括`__get__、__set__`和`__delete__`方法。`property`类实现了完整的描述符协议。通常，可以只实现部分协议。其实，我们在真实的代码中见到的大多数描述符只实现了`__get__`和`__set__`方法，还有很多只实现了其中的一个。

##### 处理属性的重要属性和函数

`__class__`对象所属类的引用（即`obj.__class__`与`type(obj)`的作用相同）。Python 的某些特殊方法，例如 `__getattr__`，只在对象的类中寻找，而不在实例中寻找。`__dict__`一个映射，存储对象或类的可写属性。有 `__dict__ `属性的对象，任何时候都能随意设置新属性。如果类有`__slots__`属性，它的实例可能没有`__dict__` 属性。`__slots__`类可以定义这个这属性，限制实例能有哪些属性。`__slots__`属性的值是一个字符串组成的元组，指明允许有的属性。 如果`__slots__`中没有`'__dict__'`，那么该类的实例没有`__dict__`属性，实例只允许有指定名称的属性。

###### 处理属性的内置函数

`getattr(object, name[, default])`从 object 对象中获取 name 字符串对应的属性。获取的属性可能来自对象所属的类或超类。如果没有指定的属性，`getattr`函数抛出`AttributeError`异常，或者返回default 参数的值。`hasattr(object, name)`如果`object`对象中存在指定的属性，或者能以某种方式通过`object`对象获取指定的属性，返回 True。`setattr(object, name, value)`把`object`对象指定属性的值设为`value`，前提是 `object`对象能接受那个值。这个函数可能会创建一个新属性，或者覆盖现有的属性。`vars([object])`返回`object`对象的`__dict__ `属性；如果实例所属的类定义了`__slots__`属性，实例没有`__dict__`属性，那么`vars`函数不能处理那个实例。如果没有指定参数，那么`vars()`函数的作用与`locals()`函数一样：返回表示本地作用域的字典。

###### 处理属性的特殊方法

`__dir__(self)`把对象传给`dir`函数时调用，列出属性。例如，`dir(obj)`触发`Class.__dir__(obj)`方法。
`__getattr__(self, name)`仅当获取指定的属性失败，搜索过`obj、Class`和超类之后调用。表达式`obj.no_such_attr、getattr(obj, 'no_such_attr')`和`hasattr(obj,'no_such_attr')`可能会触发`Class.__getattr__(obj, 'no_such_attr')`方法，但是，仅当在 obj、Class 和超类中找不到指定的属性时才会触发。`__getattribute__(self, name)`尝试获取指定的属性时总会调用这个方法，不过，寻找的属性是特殊属性或特殊方法时除外。点号与`getattr`和`hasattr`内置函数会触发这个方法。调用`__getattribute__ `方法且抛出`AttributeError`异常时，才会调用`__getattr__ `方法。为了在获取`obj`实例的属性时不导致无限递归，`__getattribute__ `方法的实现要使用`super().__getattribute__(obj, name)`。`__setattr__(self, name, value)`尝试设置指定的属性时总会调用这个方法。点号和`setattr`内置函数会触发这个方法。例如，`obj.attr = 42`和`setattr(obj, 'attr', 42)`都会触发`Class.__setattr__(obj, ‘attr’, 42)`方法。

##### 属性描述符

![](../picture/1/44.png)

描述符类：实现描述符协议的类。托管类：把描述符实例声明为类属性的类。描述符实例：描述符类的各个实例，声明为托管类的类属性。各个描述符实例使用箭头和带下划线的名称表示。与黑色菱形接触的`LineItem`类包含描述符实例。托管实例：托管类的实例。储存属性：托管实例中存储自身托管属性的属性。`LineItem`实例的`weight`和`price`属性是储存属性。这种属性与描述符属性不同，描述符属性都是类属性。托管属性：托管类中由描述符实例处理的公开属性，值存储在储存属性中。也就是说，描述符实例和储存属性为托管属性建立了基础。

```python
class Quantity:#描述符基于协议实现，无需创建子类。
    def __init__(self, name):
        self.name = name
 '''尝试为托管属性赋值时，会调用 __set__ 方法。这里，self 是描述符实例（即LineItem.weight 或 LineItem.price），instance 是托管实例（LineItem 实
例），value 是要设定的值。'''
    def __set__(self, instance, value):
        if value > 0:
            '''必须直接处理托管实例的 __dict__ 属性；如果使用内置的 setattr 函数，会再次触发 __set__ 方法，导致无限递归。'''
            instance.__dict__[self.name] = value
        else:
            raise ValueError('value must be > 0')
class LineItem:
    weight = Quantity('weight')
    price = Quantity('price')
    '''各个托管属性的名称与储存属性一样，而且读值方法不需要特殊的逻
辑，所以 Quantity 类不需要定义 __get__ 方法。'''
    def __init__(self, description, weight, price):
        self.description = description
        self.weight = weight
        self.price = price
'''编写 __set__ 方法时，要记住 self 和 instance 参数的意思：self 是描述
符实例，instance 是托管实例。管理实例属性的描述符应该把值存储在托管实例
中。因此，Python 才为描述符中的那个方法提供了 instance 参数。'''
```

实现`__set__ `方法的描述符属于覆盖型描述符，因为虽然描述符是类属性，但是实现
`__set__ `方法的话，会覆盖对实例属性的赋值操作。特性也是覆盖型描述符：如果没提供设值函数，`property`类中的`__set__`方法会抛出`AttributeError`异常，指明那个属性是只读的。通常，覆盖型描述符既会实现`__set__`方法，也会实现`__get__`方法，不过也可以只实现`__set__`方法。此时，只有写操作由描述符处理。通过实例读取描述符会返回描述符对象本身，因为没有处理读操作的`__get__`方法。如果直接通过实例的`__dict__`属性创建同名实例属性，以后再设置那个属性时，仍会由`__set__`方法插手接管，但是读取那个属性的话，就会直接从实例中返回新赋予的值，而不会返回描述符对象。也就是说，实例属性会遮盖描述符，不过只有读操作是如此。没有实现`__set__`方法的描述符是非覆盖型描述符。如果设置了同名的实例属性，描述符会被遮盖，致使描述符无法处理那个实例的那个属性。不管描述符是不是覆盖型，为类属性赋值都能覆盖描述符。这是一种猴子补丁技术，这其实会导致依赖描述符的类不能正确地
执行操作。

###### 方法是描述符

在类中定义的函数属于绑定方法，因为用户定义的函数都有`__get__`方法，所以依附到类上时，就相当于描述符。函数没有实现`__set__`方法，因此是非覆盖型描述符。与描述符一样，通过托管类访问时，函数的`__get__`方法会返回自身的引用。但是，通过实例访问时，函数的`__get__`方法返回的是绑定方法对象：一种可调用的对象，里面包装着函数，并把托管实例绑定给函数的第一个参数。绑定方法对象还有个`__call__`方法，用于处理真正的调用过程。这个方法会调用`__func__`属性引用的原始函数，把函数的第一个参数设为绑定方法的`__self__`属性。这就是形参 self 的隐式绑定方式。函数会变成绑定方法，这是 Python 语言底层使用描述符的最好例证。

**使用特性以保持简单**内置的`property`类创建的其实是覆盖型描述符，`__set__`方法和 `__get__ `方法都实现了，即便不定义设值方法也是如此。特性的`__set__`方法默认抛出`AttributeError: can't set attribute`，因此创建只读属性最简单的方式是使用特性。**只读描述符**必须有`__set__`方法如果使用描述符类实现只读属性，要记住，`__get__ `和`__set__`两个方法必须都定义，否则，实例的同名属性会遮盖描述符。只读属性的`__set__`方法只需抛出`AttributeError`异常，并提供合适的错误消息。**用于验证的描述符**可以只有`__set__`方法对仅用于验证的描述符来说，`__set__`方法应该检查`value`参数获得的值，如果有效，使用描述符实例的名称为键，直接在实例的`__dict__`属性中设置。这样，从实例中读取同名属性的速度很快，因为不用经过`__get__`方法处理。仅有`__get__`方法的描述符可以实现高效缓存如果只编写了`__get__`方法，那么创建的是非覆盖型描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例的`__dict__`属性中获取值，而不会再触发描述符的`__get__`方法。
**非特殊的方法可以被实例属性遮盖**由于函数和方法只实现了`__get__`方法，它们不会处理同名实例属性的赋值操作。因此，像`my_obj.the_method = 7`这样简单赋值之后，后续通过该实例访问`the_method`得到的是数字 7——但是不影响类或其他实例。然而，特殊方法不受这个问题的影响。解释器只会在类中寻找特殊的方法，也就是说，`repr(x)`执行的其实是`x.__class__.__repr__(x)`，因此`x`的`__repr__`属性对`repr(x)`方法调用没有影响。出于同样的原因，实例的`__getattr__`属性不会破坏常规的属性访问规则。